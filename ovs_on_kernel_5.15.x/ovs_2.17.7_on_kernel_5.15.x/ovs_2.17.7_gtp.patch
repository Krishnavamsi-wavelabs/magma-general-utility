diff --git a/Documentation/faq/releases.rst b/Documentation/faq/releases.rst
index 49895c595..506e39438 100644
--- a/Documentation/faq/releases.rst
+++ b/Documentation/faq/releases.rst
@@ -74,7 +74,7 @@ Q: What Linux kernel versions does each Open vSwitch release work with?
     2.14.x       3.16 to 5.5
     2.15.x       3.16 to 5.8
     2.16.x       3.16 to 5.8
-    2.17.x       3.16 to 5.8
+    2.17.x       3.16 to 5.15
     ============ ==============
 
     Open vSwitch userspace should also work with the Linux kernel module built
diff --git a/NEWS b/NEWS
index 9c0f9c159..1072a22df 100644
--- a/NEWS
+++ b/NEWS
@@ -250,7 +250,7 @@ v2.15.0 - 15 Feb 2021
    - The environment variable OVS_UNBOUND_CONF, if set, is now used
      as the DNS resolver's (unbound) configuration file.
    - Linux datapath:
-     * Support for kernel versions up to 5.8.x.
+     * Support for kernel versions up to 5.15.x.
    - Terminology:
      * The terms "master" and "slave" have been replaced by "primary" and
        "secondary", respectively, for OpenFlow connection roles.
diff --git a/acinclude.m4 b/acinclude.m4
index c981f90bc..8ed7360d8 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -223,10 +223,10 @@ AC_DEFUN([OVS_CHECK_LINUX], [
     AC_MSG_RESULT([$kversion])
 
     if test "$version" -ge 5; then
-       if test "$version" = 5 && test "$patchlevel" -le 8; then
+       if test "$version" = 5 && test "$patchlevel" -le 15; then
           : # Linux 5.x
        else
-          AC_ERROR([Linux kernel in $KBUILD is version $kversion, but version newer than 5.8.x is not supported (please refer to the FAQ for advice)])
+          AC_ERROR([Linux kernel in $KBUILD is version $kversion, but version newer than 5.15.x is not supported (please refer to the FAQ for advice)])
        fi
     elif test "$version" = 4; then
        : # Linux 4.x
@@ -719,6 +719,8 @@ AC_DEFUN([OVS_CHECK_LINUX_COMPAT], [
 
   OVS_GREP_IFELSE([$KSRC/include/uapi/linux/if_link.h], [IFLA_GENEVE_TOS])
   OVS_GREP_IFELSE([$KSRC/include/uapi/linux/if_link.h], [rtnl_link_stats64])
+  OVS_GREP_IFELSE([$KSRC/include/uapi/linux/if_link.h], [GTP_ROLE_GGSN])
+  OVS_GREP_IFELSE([$KSRC/include/uapi/linux/if_link.h], [IFLA_GTP_ROLE])
   OVS_GREP_IFELSE([$KSRC/include/linux/if_link.h], [rtnl_link_stats64])
   OVS_GREP_IFELSE([$KSRC/include/linux/if_vlan.h], [vlan_set_encap_proto])
   OVS_GREP_IFELSE([$KSRC/include/linux/if_vlan.h], [vlan_hwaccel_push_inside])
@@ -753,6 +755,7 @@ AC_DEFUN([OVS_CHECK_LINUX_COMPAT], [
                   [OVS_DEFINE([HAVE_INET_FRAGS_LAST_IN])])
   OVS_GREP_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frag_evicting])
   OVS_GREP_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frag_evictor])
+  OVS_GREP_IFELSE([$KSRC/include/net/ipv6_frag.h], [_IPV6_FRAG_H])
   OVS_FIND_FIELD_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frags],
                         [frags_work])
   OVS_FIND_FIELD_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frags],
@@ -1051,6 +1054,7 @@ AC_DEFUN([OVS_CHECK_LINUX_COMPAT], [
                   [OVS_DEFINE([HAVE_NET_NAME_UNKNOWN])])
 
   OVS_GREP_IFELSE([$KSRC/include/net/sock.h], [sk_no_check_tx])
+  OVS_GREP_IFELSE([$KSRC/include/net/sock.h], [refcount_read], [OVS_DEFINE([HAVE_SOCK_REFCNT])])
   OVS_GREP_IFELSE([$KSRC/include/linux/udp.h], [no_check6_tx])
   OVS_FIND_PARAM_IFELSE([$KSRC/include/net/protocol.h],
                         [udp_add_offload], [net],
diff --git a/datapath/Modules.mk b/datapath/Modules.mk
index 3c4ae366c..9d930f7a1 100644
--- a/datapath/Modules.mk
+++ b/datapath/Modules.mk
@@ -8,6 +8,7 @@ both_modules = \
 	$(build_multi_modules) \
 	vport_geneve \
 	vport_gre \
+	vport_gtp \
 	vport_lisp \
 	vport_stt \
 	vport_vxlan
@@ -33,6 +34,7 @@ openvswitch_sources = \
 vport_geneve_sources = vport-geneve.c
 vport_vxlan_sources = vport-vxlan.c
 vport_gre_sources = vport-gre.c
+vport_gtp_sources = vport-gtp.c
 vport_lisp_sources = vport-lisp.c
 vport_stt_sources = vport-stt.c
 nsh_sources = nsh.c
diff --git a/datapath/flow_netlink.c b/datapath/flow_netlink.c
index 996041602..d7e7cd31a 100644
--- a/datapath/flow_netlink.c
+++ b/datapath/flow_netlink.c
@@ -23,6 +23,7 @@
 #include <linux/etherdevice.h>
 #include <linux/if_ether.h>
 #include <linux/if_vlan.h>
+#include <linux/gtp.h>
 #include <net/llc_pdu.h>
 #include <linux/kernel.h>
 #include <linux/jhash.h>
@@ -40,9 +41,11 @@
 #include <linux/icmp.h>
 #include <linux/icmpv6.h>
 #include <linux/rculist.h>
+#include <linux/openvswitch.h>
 #include <net/geneve.h>
 #include <net/ip.h>
 #include <net/ipv6.h>
+#include <net/ip_tunnels.h>
 #include <net/ndisc.h>
 #include <net/mpls.h>
 #include <net/vxlan.h>
@@ -406,6 +409,7 @@ static const struct ovs_len_tbl ovs_tunnel_key_lens[OVS_TUNNEL_KEY_ATTR_MAX + 1]
 	[OVS_TUNNEL_KEY_ATTR_IPV6_SRC]      = { .len = sizeof(struct in6_addr) },
 	[OVS_TUNNEL_KEY_ATTR_IPV6_DST]      = { .len = sizeof(struct in6_addr) },
 	[OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS]   = { .len = OVS_ATTR_VARIABLE },
+	[OVS_TUNNEL_KEY_ATTR_GTPU_OPTS]   = { .len = OVS_ATTR_VARIABLE },
 };
 
 static const struct ovs_len_tbl
@@ -664,6 +668,33 @@ static int erspan_tun_opt_from_nlattr(const struct nlattr *a,
 	return 0;
 }
 
+static int gtp_tun_opt_from_nlattr(const struct nlattr *a,
+				   struct sw_flow_match *match, bool is_mask,
+				   bool log)
+{
+	unsigned long opt_key_offset;
+
+	BUILD_BUG_ON(sizeof(struct gtpu_metadata) >
+		     sizeof(match->key->tun_opts));
+
+	if (nla_len(a) > sizeof(match->key->tun_opts)) {
+		OVS_NLERR(log, "GTP option length err (len %d, max %zu).",
+			  nla_len(a), sizeof(match->key->tun_opts));
+		return -EINVAL;
+	}
+
+	if (!is_mask)
+		SW_FLOW_KEY_PUT(match, tun_opts_len,
+				sizeof(struct gtpu_metadata), false);
+	else
+		SW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);
+
+	opt_key_offset = TUN_METADATA_OFFSET(nla_len(a));
+	SW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, nla_data(a),
+				  nla_len(a), is_mask);
+	return 0;
+}
+
 static int ip_tun_from_nlattr(const struct nlattr *attr,
 			      struct sw_flow_match *match, bool is_mask,
 			      bool log)
@@ -785,6 +816,21 @@ static int ip_tun_from_nlattr(const struct nlattr *attr,
 			tun_flags |= TUNNEL_ERSPAN_OPT;
 			opts_type = type;
 			break;
+		case OVS_TUNNEL_KEY_ATTR_GTPU_OPTS:
+			if (opts_type) {
+				OVS_NLERR(log, "Multiple metadata blocks provided");
+				return -EINVAL;
+			}
+
+			err = gtp_tun_opt_from_nlattr(a, match, is_mask,
+							 log);
+			if (err)
+				return err;
+
+			tun_flags |= TUNNEL_GTPU_OPT;
+			opts_type = type;
+			break;
+
 		default:
 			OVS_NLERR(log, "Unknown IP tunnel attribute %d",
 				  type);
@@ -913,6 +959,10 @@ static int __ip_tun_to_nlattr(struct sk_buff *skb,
 			 nla_put(skb, OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS,
 				 swkey_tun_opts_len, tun_opts))
 			return -EMSGSIZE;
+		else if (output->tun_flags & TUNNEL_GTPU_OPT &&
+			 nla_put(skb, OVS_TUNNEL_KEY_ATTR_GTPU_OPTS,
+				 swkey_tun_opts_len, tun_opts))
+			return -EMSGSIZE;
 	}
 
 	return 0;
@@ -1995,7 +2045,8 @@ static int __ovs_nla_put_key(const struct sw_flow_key *swkey,
 	if ((swkey->tun_proto || is_mask)) {
 		const void *opts = NULL;
 
-		if (output->tun_key.tun_flags & TUNNEL_OPTIONS_PRESENT)
+		if (swkey->tun_opts_len ||
+                        (output->tun_key.tun_flags & TUNNEL_OPTIONS_PRESENT))
 			opts = TUN_METADATA_OPTS(output, swkey->tun_opts_len);
 
 		if (ip_tun_to_nlattr(skb, &output->tun_key, opts,
@@ -2602,6 +2653,9 @@ static int validate_and_copy_set_tun(const struct nlattr *attr,
 		case OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS:
 			dst_opt_type = TUNNEL_ERSPAN_OPT;
 			break;
+		case OVS_TUNNEL_KEY_ATTR_GTPU_OPTS:
+			dst_opt_type = TUNNEL_GTPU_OPT;
+			break;
 		}
 	}
 
diff --git a/datapath/linux/Modules.mk b/datapath/linux/Modules.mk
index 372243988..9d47dac4b 100644
--- a/datapath/linux/Modules.mk
+++ b/datapath/linux/Modules.mk
@@ -4,6 +4,7 @@ openvswitch_sources += \
 	linux/compat/exthdrs_core.c \
 	linux/compat/geneve.c \
 	linux/compat/gre.c \
+	linux/compat/gtp.c \
 	linux/compat/gso.c \
 	linux/compat/genetlink-openvswitch.c \
 	linux/compat/inet_fragment.c \
@@ -41,6 +42,7 @@ openvswitch_headers += \
 	linux/compat/include/linux/err.h \
 	linux/compat/include/linux/etherdevice.h \
 	linux/compat/include/linux/genetlink.h \
+	linux/compat/include/linux/gtp.h \
 	linux/compat/include/linux/if.h \
 	linux/compat/include/linux/if_ether.h \
 	linux/compat/include/linux/if_link.h \
@@ -78,6 +80,7 @@ openvswitch_headers += \
 	linux/compat/include/net/genetlink.h \
 	linux/compat/include/net/geneve.h \
 	linux/compat/include/net/gre.h \
+	linux/compat/include/net/gtp.h \
 	linux/compat/include/net/inet_ecn.h \
 	linux/compat/include/net/inet_frag.h \
 	linux/compat/include/net/inetpeer.h \
diff --git a/datapath/linux/compat/geneve.c b/datapath/linux/compat/geneve.c
index 02c6403e6..3a19683b6 100644
--- a/datapath/linux/compat/geneve.c
+++ b/datapath/linux/compat/geneve.c
@@ -1308,7 +1308,11 @@ static const struct net_device_ops geneve_netdev_ops = {
 	.ndo_open		= geneve_open,
 	.ndo_stop		= geneve_stop,
 	.ndo_start_xmit		= geneve_dev_xmit,
-	.ndo_get_stats64	= ip_tunnel_get_stats64,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        .ndo_get_stats64        = dev_get_tstats64,
+#else
+        .ndo_get_stats64        = ip_tunnel_get_stats64,
+#endif
 #ifdef	HAVE_RHEL7_MAX_MTU
 	.ndo_size		= sizeof(struct net_device_ops),
 	.extended.ndo_change_mtu = geneve_change_mtu,
diff --git a/datapath/linux/compat/gtp.c b/datapath/linux/compat/gtp.c
new file mode 100644
index 000000000..ba5c26437
--- /dev/null
+++ b/datapath/linux/compat/gtp.c
@@ -0,0 +1,1096 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/* GTP according to GSM TS 09.60 / 3GPP TS 29.060
+ *
+ * (C) 2012-2014 by sysmocom - s.f.m.c. GmbH
+ * (C) 2016 by Pablo Neira Ayuso <pablo@netfilter.org>
+ *
+ * Author: Harald Welte <hwelte@sysmocom.de>
+ *	   Pablo Neira Ayuso <pablo@netfilter.org>
+ *	   Andreas Schultz <aschultz@travelping.com>
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/udp.h>
+#include <linux/rculist.h>
+#include <linux/jhash.h>
+#include <linux/if_tunnel.h>
+#include <linux/net.h>
+#include <linux/file.h>
+#include <linux/gtp.h>
+#include <linux/sctp.h>
+
+#include <net/dst_metadata.h>
+#include <net/net_namespace.h>
+#include <net/protocol.h>
+#include <net/ip.h>
+#include <net/udp.h>
+#include <net/udp_tunnel.h>
+#include <net/ipv6_stubs.h>
+#include <net/icmp.h>
+#include <net/xfrm.h>
+#include <net/genetlink.h>
+#include <net/netns/generic.h>
+#include <net/gtp.h>
+
+#include "gso.h"
+#include "vport-netdev.h"
+#include "compat.h"
+
+
+#define GTP_PDP_HASHSIZE 1024
+#define GTPA_PEER_ADDRESS GTPA_SGSN_ADDRESS /* maintain legacy attr name */
+#define GTP_EXTENSION_HDR_FLAG 0x04
+#define GTP_SEQ_FLAG           0x02
+
+#define GTP_TYPE_END_MARKER 0xFE
+
+struct gtpu_ext_hdr {
+	__be16 seq_num;
+	u8 n_pdu;
+		u8 type;
+};
+
+struct gtpu_ext_hdr_pdu_sc {
+	u8 len;
+	u8 pdu_type;
+	u8 qfi;
+		u8 next_type;
+};
+
+/* One instance of the GTP device. */
+struct gtp_dev {
+	struct list_head	list;
+
+	struct net_device	*dev;
+	struct sock		*sk1u;
+	struct sock		*sk1u_v6;
+
+	__be16			gtph_port;
+};
+
+static unsigned int gtp_net_id __read_mostly;
+
+struct gtp_net {
+	struct list_head gtp_dev_list;
+};
+
+static int check_header(struct sk_buff *skb, int len)
+{
+	if (unlikely(skb->len < len))
+		return -EINVAL;
+	if (unlikely(!pskb_may_pull(skb, len)))
+		return -ENOMEM;
+	return 0;
+}
+
+static int gtp_rx(struct sock *sk, struct gtp_dev *gtp, struct sk_buff *skb,
+			unsigned int hdrlen, u8 gtp_version,
+			__be64 tid, u8 flags, u8 type)
+{
+#ifndef USE_UPSTREAM_TUNNEL
+	union {
+		struct metadata_dst dst;
+		char buf[sizeof(struct metadata_dst) + sizeof (struct gtpu_metadata)];
+	} buf;
+#endif
+	struct pcpu_sw_netstats *stats;
+	int err;
+
+#ifndef USE_UPSTREAM_TUNNEL
+		struct metadata_dst *tun_dst = &buf.dst;
+#endif
+
+		int opts_len;
+	 	opts_len = sizeof (struct gtpu_metadata);
+#ifndef USE_UPSTREAM_TUNNEL
+		//udp_tun_rx_dst
+		ovs_udp_tun_rx_dst(tun_dst, skb, sk->sk_family, TUNNEL_KEY, tid, opts_len);
+#else
+		struct metadata_dst *tun_dst =
+			udp_tun_rx_dst(skb, sk->sk_family, TUNNEL_KEY, tid, opts_len);
+#endif
+		netdev_dbg(gtp->dev, "attaching metadata_dst to skb, gtp ver %d hdrlen %d\n", gtp_version, hdrlen);
+                if (unlikely(opts_len)) {
+                    struct gtpu_metadata *opts = ip_tunnel_info_opts(&tun_dst->u.tun_info);
+                    struct gtp1_header *gtp1 = (struct gtp1_header *)(skb->data + sizeof(struct udphdr));
+		    if (likely(type == GTP_TPDU)){
+	                struct gtpu_ext_hdr *geh;
+			geh = (struct gtpu_ext_hdr *) (gtp1 + 1);
+			if (geh->type == 0x85) {
+			    struct gtpu_ext_hdr_pdu_sc *pdu_sc_hd;
+			    pdu_sc_hd = (struct gtpu_ext_hdr_pdu_sc *) (geh + 1);
+			    if (pdu_sc_hd->qfi) {
+                                opts_len = sizeof (struct gtpu_metadata);
+                                opts->ver = GTP_METADATA_V1;
+                                opts->flags = gtp1->flags;
+                                opts->type = gtp1->type;
+                                opts->qfi = pdu_sc_hd->qfi;
+                                opts_len = opts_len + sizeof(struct gtpu_ext_hdr) + sizeof(struct gtpu_ext_hdr_pdu_sc);
+                                tun_dst->u.tun_info.key.tun_flags |= TUNNEL_GTPU_OPT;
+                                tun_dst->u.tun_info.options_len = opts_len;
+                            }
+                        }
+		    } else {
+		        opts->ver = GTP_METADATA_V1;
+                        opts->flags = gtp1->flags;
+                        opts->type = gtp1->type;
+                        netdev_dbg(gtp->dev, "recved control pkt: flag %x type: %d\n", opts->flags, opts->type);
+                        tun_dst->u.tun_info.key.tun_flags |= TUNNEL_GTPU_OPT;
+                        tun_dst->u.tun_info.options_len = opts_len;
+                        skb->protocol = 0xffff;         // Unknown
+			if (gtp1->type == GTP_TYPE_END_MARKER) {
+				// dont pull the headers
+				hdrlen = sizeof(struct udphdr);
+				netdev_dbg(gtp->dev, "End marker packet len: %d", skb->len);
+			}
+                    }
+		}
+
+		/* Get rid of the GTP + UDP headers. */
+		if (iptunnel_pull_header(skb, hdrlen, skb->protocol,
+					!net_eq(sock_net(sk), dev_net(gtp->dev)))) {
+			err = -1;
+			gtp->dev->stats.rx_length_errors++;
+			goto err;
+		}
+
+		ovs_skb_dst_set(skb, &tun_dst->dst);
+		netdev_dbg(gtp->dev, "forwarding packet from GGSN to uplink\n");
+
+	/* Now that the UDP and the GTP header have been removed, set up the
+	 * new network header. This is required by the upper layer to
+	 * calculate the transport header.
+	 */
+	skb_reset_network_header(skb);
+	if (!check_header(skb, sizeof(struct iphdr))) {
+		struct iphdr *iph;
+
+		iph = ip_hdr(skb);
+		if (iph->version == 4) {
+			netdev_dbg(gtp->dev, "inner pkt: ipv4");
+			skb->protocol = htons(ETH_P_IP);
+		} else if (iph->version == 6) {
+			netdev_dbg(gtp->dev, "inner pkt: ipv6");
+			skb->protocol = htons(ETH_P_IPV6);
+		} else {
+			netdev_dbg(gtp->dev, "inner pkt: control pkt");
+		}
+	}
+
+	skb->dev = gtp->dev;
+
+	stats = this_cpu_ptr(gtp->dev->tstats);
+	u64_stats_update_begin(&stats->syncp);
+	stats->rx_packets++;
+	stats->rx_bytes += skb->len;
+	u64_stats_update_end(&stats->syncp);
+
+#ifndef USE_UPSTREAM_TUNNEL
+	netdev_port_receive(skb, skb_tunnel_info(skb));
+#else
+	netif_rx(skb);
+#endif
+	return 0;
+
+err:
+	gtp->dev->stats.rx_dropped++;
+	return err;
+}
+
+/* 1 means pass up to the stack, -1 means drop and 0 means decapsulated. */
+
+static int gtp1u_udp_encap_recv(struct sock *sk, struct gtp_dev *gtp, struct sk_buff *skb)
+{
+	unsigned int hdrlen = sizeof(struct udphdr) +
+				  sizeof(struct gtp1_header);
+	struct gtp1_header *gtp1;
+
+	if (!pskb_may_pull(skb, hdrlen))
+		return -1;
+
+	gtp1 = (struct gtp1_header *)(skb->data + sizeof(struct udphdr));
+
+	netdev_dbg(gtp->dev, "flags %x type: %x\n", gtp1->flags, gtp1->type);
+	if ((gtp1->flags >> 5) != GTP_V1)
+		return 1;
+
+	/* From 29.060: "This field shall be present if and only if any one or
+	 * more of the S, PN and E flags are set.".
+	 *
+	 * If any of the bit is set, then the remaining ones also have to be
+	 * set.
+	 */
+		if (gtp1->type == GTP_TPDU) {
+			if (gtp1->flags & GTP_EXTENSION_HDR_FLAG) {
+				struct gtpu_ext_hdr *geh;
+				u8 next_hdr;
+
+				geh = (struct gtpu_ext_hdr *) (gtp1 + 1);
+				netdev_dbg(gtp->dev, "ext type type %d, seq:%d, n_pdu:%d\n", geh->type, geh->seq_num, geh->n_pdu);
+
+				hdrlen += sizeof (struct gtpu_ext_hdr);
+				next_hdr = geh->type;
+				while (next_hdr) {
+					u8 len = *(u8 *) (skb->data + hdrlen);
+
+					hdrlen += (len * 4);
+					if (!pskb_may_pull(skb, hdrlen)) {
+						netdev_dbg(gtp->dev, "malformed packet %d", hdrlen);
+						return -1;
+					}
+					next_hdr = *(u8*) (skb->data + hdrlen - 1);
+					netdev_dbg(gtp->dev, "current hdr len %d next hdr type: %d\n", len, next_hdr);
+				}
+				netdev_dbg(gtp->dev, "pkt type: %x", *(u8*) (skb->data + hdrlen));
+				netdev_dbg(gtp->dev, "skb-len %d gtp len %d hdr len %d\n", skb->len, (int) ntohs(gtp1->length), hdrlen);
+			} else if (gtp1->flags & GTP1_F_MASK)
+				hdrlen += 4;
+		}
+
+	/* Make sure the header is larger enough, including extensions. */
+	if (!pskb_may_pull(skb, hdrlen))
+		return -1;
+
+	gtp1 = (struct gtp1_header *)(skb->data + sizeof(struct udphdr));
+
+	return gtp_rx(sk, gtp, skb, hdrlen, GTP_V1, key32_to_tunnel_id(gtp1->tid), gtp1->flags, gtp1->type);
+}
+
+static void __gtp_encap_destroy(struct sock *sk)
+{
+	struct gtp_dev *gtp;
+
+	lock_sock(sk);
+	gtp = sk->sk_user_data;
+	if (gtp) {
+		gtp->sk1u = NULL;
+		gtp->sk1u_v6 = NULL;
+		udp_sk(sk)->encap_type = 0;
+		rcu_assign_sk_user_data(sk, NULL);
+		sock_put(sk);
+	}
+	release_sock(sk);
+}
+
+static void gtp_encap_destroy(struct sock *sk)
+{
+	__gtp_encap_destroy(sk);
+}
+
+static void gtp_encap_disable_sock(struct sock *sk)
+{
+	if (!sk)
+		return;
+
+	__gtp_encap_destroy(sk);
+}
+
+static void gtp_encap_disable(struct gtp_dev *gtp)
+{
+	gtp_encap_disable_sock(gtp->sk1u);
+	gtp_encap_disable_sock(gtp->sk1u_v6);
+}
+
+/* UDP encapsulation receive handler. See net/ipv4/udp.c.
+ * Return codes: 0: success, <0: error, >0: pass up to userspace UDP socket.
+ */
+static int gtp_encap_recv(struct sock *sk, struct sk_buff *skb)
+{
+	struct gtp_dev *gtp;
+	int ret = 0;
+
+	gtp = rcu_dereference_sk_user_data(sk);
+	if (!gtp)
+		return 1;
+
+	netdev_dbg(gtp->dev, "encap_recv sk=%p type %d\n", sk, udp_sk(sk)->encap_type);
+
+	ret = gtp1u_udp_encap_recv(sk, gtp, skb);
+	switch (ret) {
+	case 1:
+		netdev_dbg(gtp->dev, "pass up to the process\n");
+		break;
+	case 0:
+		break;
+	case -1:
+		netdev_dbg(gtp->dev, "GTP packet has been dropped\n");
+		kfree_skb(skb);
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static int gtp_dev_init(struct net_device *dev)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+
+	gtp->dev = dev;
+
+	dev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);
+	if (!dev->tstats)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void gtp_dev_uninit(struct net_device *dev)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+
+	gtp_encap_disable(gtp);
+	free_percpu(dev->tstats);
+}
+
+static unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
+{
+		const struct skb_shared_info *shinfo = skb_shinfo(skb);
+		unsigned int thlen = 0;
+
+		if (skb->encapsulation) {
+				thlen = skb_inner_transport_header(skb) -
+						skb_transport_header(skb);
+
+				if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
+						thlen += inner_tcp_hdrlen(skb);
+		} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
+				thlen = tcp_hdrlen(skb);
+		} else if (unlikely(skb_is_gso_sctp(skb))) {
+				thlen = sizeof(struct sctphdr);
+		} else if (shinfo->gso_type & SKB_GSO_UDP_L4) {
+				thlen = sizeof(struct udphdr);
+		}
+		/* UFO sets gso_size to the size of the fragmentation
+		 * payload, i.e. the size of the L4 (UDP) header is already
+		 * accounted for.
+		 */
+		return thlen + shinfo->gso_size;
+}
+
+static unsigned int skb_gso_network_seglen(const struct sk_buff *skb)
+{
+		unsigned int hdr_len = skb_transport_header(skb) -
+							   skb_network_header(skb);
+
+		return hdr_len + skb_gso_transport_seglen(skb);
+}
+
+static inline void gtp1_push_header(struct net_device *dev, struct sk_buff *skb, __be32 tid, __u8 qfi)
+{
+	struct gtpu_ext_hdr *next_hdr;
+	struct gtpu_ext_hdr_pdu_sc *pdu_sc;
+	struct gtp1_header *gtp1;
+	int payload_len;
+	__u8 flags = 0x30;
+
+	if (skb_is_gso(skb)) {
+		payload_len = skb_gso_network_seglen(skb);
+		netdev_dbg(dev, "gso_size %d skb_gso_network_seglen(skb) %d skb->len %d\n",
+				skb_shinfo(skb)->gso_size, skb_gso_network_seglen(skb), skb->len);
+	} else {
+		netdev_dbg(dev,"No gso len %d\n", skb->len);
+		payload_len = skb->len;
+	}
+	if (qfi) {
+		gtp1 = (struct gtp1_header *) skb_push(skb, sizeof(*gtp1) + sizeof (*next_hdr) + sizeof (*pdu_sc));
+		payload_len += (sizeof(*next_hdr) + sizeof(*pdu_sc));
+		flags = flags | GTP_EXTENSION_HDR_FLAG;
+	} else {
+		gtp1 = (struct gtp1_header *) skb_push(skb, sizeof(*gtp1));
+	}
+
+	/* Bits    8  7  6  5  4  3  2	1
+	 *	  +--+--+--+--+--+--+--+--+
+	 *	  |version |PT| 0| E| S|PN|
+	 *	  +--+--+--+--+--+--+--+--+
+	 *	    0  0  1  1	1  0  0  0
+	 */
+	gtp1->flags	= flags; /* v1, GTP-non-prime. */
+	gtp1->type	= GTP_TPDU;
+	gtp1->length	= htons(payload_len);
+	gtp1->tid	= tid;
+
+		if (qfi) {
+				/* TODO: Suppport for extension header, sequence number and N-PDU.
+				 *       Update the length field if any of them is available.
+				 */
+				struct gtpu_ext_hdr_pdu_sc pdu_sc_hdr;
+				pdu_sc_hdr.len = 1;
+                                pdu_sc_hdr.pdu_type = 0x0; /* PDU_TYPE_DL_PDU_SESSION_INFORMATION */
+                                pdu_sc_hdr.qfi = qfi;
+                                pdu_sc_hdr.next_type = 0;
+
+			        next_hdr = (struct gtpu_ext_hdr *) (gtp1 + 1);
+				next_hdr->type = 0x85;
+				pdu_sc = (struct gtpu_ext_hdr_pdu_sc *) (next_hdr + 1);
+				*pdu_sc = pdu_sc_hdr;
+				netdev_dbg(dev,"Update QFI value for downlink %d for teid %d\n", pdu_sc->qfi, tid);
+		}
+
+}
+
+static inline int gtp1_push_control_header(struct sk_buff *skb, __be32 tid, struct gtpu_metadata *opts,
+		struct net_device *dev)
+{
+	struct gtp1_header *gtp1c;
+	int payload_len;
+
+	if (opts->ver != GTP_METADATA_V1) {
+		return -ENOENT;
+	}
+
+	if (opts->type == GTP_TYPE_END_MARKER) {
+		// for end marker ignore skb data.
+		netdev_dbg(dev, "xmit pkt with null data");
+		pskb_trim(skb, 0);
+	}
+	if (skb_cow_head(skb, sizeof (*gtp1c)) < 0)
+		return -ENOMEM;
+
+	payload_len = skb->len;
+
+	gtp1c = (struct gtp1_header *) skb_push(skb, sizeof(*gtp1c));
+
+	gtp1c->flags	= opts->flags;
+	gtp1c->type	= opts->type;
+	gtp1c->length	= htons(payload_len);
+	gtp1c->tid	= tid;
+	netdev_dbg(dev, "GTP control pkt: ver %d flags %x type %x pkt len %d tid %x",
+			   opts->ver, opts->flags, opts->type, skb->len, tid);
+	return 0;
+}
+
+static struct rtable *gtp_get_v4_rt(struct sk_buff *skb,
+									   struct net_device *dev,
+									   struct sock *gs4,
+									   struct flowi4 *fl4,
+									   const struct ip_tunnel_info *info)
+{
+	struct rtable *rt = NULL;
+
+	if (!gs4)
+		return ERR_PTR(-EIO);
+
+	memset(fl4, 0, sizeof(*fl4));
+	fl4->flowi4_mark = skb->mark;
+	fl4->flowi4_proto = IPPROTO_UDP;
+	fl4->daddr = info->key.u.ipv4.dst;
+	fl4->saddr = info->key.u.ipv4.src;
+	fl4->flowi4_tos = RT_TOS(info->key.tos);
+
+	rt = ip_route_output_key(dev_net(dev), fl4);
+	if (IS_ERR(rt)) {
+		netdev_dbg(dev, "no route to %pI4\n", &fl4->daddr);
+		return ERR_PTR(-ENETUNREACH);
+	}
+	if (rt->dst.dev == dev) { /* is this necessary? */
+		netdev_dbg(dev, "circular route to %pI4\n", &fl4->daddr);
+		ip_rt_put(rt);
+		return ERR_PTR(-ELOOP);
+	}
+	return rt;
+}
+
+static struct dst_entry *gtp_get_v6_rt(struct sk_buff *skb,
+									   struct net_device *dev,
+									   struct sock *gs6,
+									   struct flowi6 *fl6,
+									   const struct ip_tunnel_info *info)
+{
+	struct dst_entry *ndst;
+
+	if (!gs6)
+		return ERR_PTR(-EIO);
+
+	memset(fl6, 0, sizeof(*fl6));
+	fl6->flowi6_mark = skb->mark;
+	fl6->flowi6_proto = IPPROTO_UDP;
+	fl6->daddr = info->key.u.ipv6.dst;
+	fl6->saddr = info->key.u.ipv6.src;
+	fl6->flowlabel = ip6_make_flowinfo(RT_TOS(info->key.tos), info->key.label);
+
+	ndst = ipv6_stub->ipv6_dst_lookup_flow(dev_net(dev), gs6,
+						   fl6, NULL);
+	if (IS_ERR(ndst)) {
+		netdev_dbg(dev, "no route to %pI6\n", &fl6->daddr);
+		return ERR_PTR(-ENETUNREACH);
+	}
+
+	if (unlikely(ndst->dev == dev)) {
+		netdev_dbg(dev, "circular route to %pI6\n", &fl6->daddr);
+		dst_release(ndst);
+		return ERR_PTR(-ELOOP);
+	}
+
+	return ndst;
+}
+
+static netdev_tx_t gtp_dev_xmit_fb(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+	struct gtp_dev *gtp = netdev_priv(dev);
+	struct dst_entry *ndst = NULL;
+	struct rtable *rt;
+	struct flowi4 fl4;
+	int min_headroom;
+	struct flowi6 fl6;
+	__be16 df;
+		__u8 ttl;
+		__u8 set_qfi = 0;
+		__u8 csum;
+		int err;
+	int mtu;
+
+	/* Read the IP destination address and resolve the PDP context.
+	 * Prepend PDP header with TEI/TID from PDP ctx.
+	 */
+
+	if (!info) {
+		netdev_dbg(dev, "no info for tunnel xmit\n");
+		goto err;
+	}
+
+	if (ip_tunnel_info_af(info) == AF_INET) {
+		rt = gtp_get_v4_rt(skb, dev, gtp->sk1u, &fl4, info);
+
+		if (IS_ERR(rt)) {
+				netdev_dbg(dev, "no route to SSGN %pI4\n", &fl4.daddr);
+				dev->stats.tx_carrier_errors++;
+				goto err;
+		}
+		skb_dst_drop(skb);
+		csum = !!(info->key.tun_flags & TUNNEL_CSUM);
+		err = udp_tunnel_handle_offloads(skb, csum);
+		if (err)
+			goto err_rt;
+		ovs_skb_set_inner_protocol(skb, cpu_to_be16(ETH_P_IP));
+
+		ttl = info->key.ttl;
+		df = info->key.tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;
+
+		/* hack to handle MTU */
+		if (df) {
+			mtu = dst_mtu(&rt->dst) - dev->hard_header_len -
+				sizeof(struct iphdr) - sizeof(struct udphdr);
+			mtu -= sizeof(struct gtp1_header);
+		} else {
+			mtu = dst_mtu(&rt->dst);
+		}
+		min_headroom = LL_RESERVED_SPACE(rt->dst.dev) + rt->dst.header_len
+					+ sizeof(struct gtp1_header) + sizeof(struct iphdr)
+					+ info->options_len;
+
+		err = skb_cow_head(skb, min_headroom);
+		if (unlikely(err))
+			goto err_rt;
+
+		netdev_dbg(dev, "packet with opt len %d", info->options_len);
+		if (info->options_len == 0) {
+		    gtp1_push_header(dev, skb, tunnel_id_to_key32(info->key.tun_id), set_qfi);
+		} else if (info->key.tun_flags & TUNNEL_GTPU_OPT) {
+		    struct gtpu_metadata *opts = ip_tunnel_info_opts(info);
+		    __be32 tid = tunnel_id_to_key32(info->key.tun_id);
+		    if (info->key.tun_flags & TUNNEL_OAM) {
+                        set_qfi = opts->qfi;
+			gtp1_push_header(dev, skb, tunnel_id_to_key32(info->key.tun_id), set_qfi);
+                    }
+                    else {
+		        int err;
+			err = gtp1_push_control_header(skb, tid, opts, dev);
+			if (err) {
+			    netdev_info(dev, "cntr pkt error %d", err);
+			    goto err_rt;
+			}
+		    }
+		} else {
+		    netdev_dbg(dev, "Missing tunnel OPT");
+		    goto err_rt;
+		}
+		udp_tunnel_xmit_skb(rt, gtp->sk1u, skb,
+					fl4.saddr, fl4.daddr, fl4.flowi4_tos, ttl, df,
+					gtp->gtph_port, gtp->gtph_port,
+					!net_eq(sock_net(gtp->sk1u), dev_net(dev)),
+								!csum);
+	} else {
+		ndst = gtp_get_v6_rt(skb, dev, gtp->sk1u_v6, &fl6, info);
+
+		if (IS_ERR(ndst)) {
+			netdev_dbg(dev, "no route to SSGN %pI4\n", &fl4.daddr);
+			dev->stats.tx_carrier_errors++;
+			goto err;
+		}
+
+		skb_dst_drop(skb);
+		csum = !!(info->key.tun_flags & TUNNEL_CSUM);
+		err = udp_tunnel_handle_offloads(skb, csum);
+		if (err)
+		    goto err_rt;
+		netdev_dbg(dev, "skb->protocol %d\n", skb->protocol);
+		ovs_skb_set_inner_protocol(skb, cpu_to_be16(ETH_P_IPV6));
+
+		ttl = info->key.ttl;
+		skb_scrub_packet(skb, !net_eq(sock_net(gtp->sk1u), dev_net(dev)));
+	        if (info->options_len == 0) {
+                    gtp1_push_header(dev, skb, tunnel_id_to_key32(info->key.tun_id), set_qfi);
+                } else if (info->key.tun_flags & TUNNEL_GTPU_OPT) {
+                    struct gtpu_metadata *opts = ip_tunnel_info_opts(info);
+                    __be32 tid = tunnel_id_to_key32(info->key.tun_id);
+                    if (info->key.tun_flags & TUNNEL_OAM) {
+                        set_qfi = opts->qfi;
+                        gtp1_push_header(dev, skb, tunnel_id_to_key32(info->key.tun_id), set_qfi);
+                    } else {
+                        int err;
+                        err = gtp1_push_control_header(skb, tid, opts, dev);
+                        if (err) {
+                            netdev_info(dev, "cntr pkt error %d", err);
+                            goto err_rt;
+                        }
+                    }
+                } else {
+                    netdev_dbg(dev, "Missing tunnel OPT");
+                    goto err_rt;
+                }
+
+		udp_tunnel6_xmit_skb(ndst, gtp->sk1u_v6, skb, dev,
+					&fl6.saddr, &fl6.daddr, RT_TOS(info->key.tos), ttl,
+					info->key.label, gtp->gtph_port, gtp->gtph_port,
+								!csum);
+	}
+	return NETDEV_TX_OK;
+err_rt:
+	ip_rt_put(rt);
+err:
+	dev->stats.tx_errors++;
+	dev_kfree_skb(skb);
+	return NETDEV_TX_OK;
+}
+
+static netdev_tx_t gtp_dev_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	/* Ensure there is sufficient headroom. */
+	if (skb_cow_head(skb, dev->needed_headroom))
+		goto tx_err;
+
+	return gtp_dev_xmit_fb(skb, dev);
+tx_err:
+	dev->stats.tx_errors++;
+	dev_kfree_skb(skb);
+	return NETDEV_TX_OK;
+}
+
+static int gtp_change_mtu(struct net_device *dev, int new_mtu, bool strict)
+{
+		int max_mtu = IP_MAX_MTU - dev->hard_header_len - sizeof(struct iphdr)
+						- sizeof(struct udphdr) - sizeof(struct gtp1_header);
+
+		if (new_mtu < ETH_MIN_MTU)
+				return -EINVAL;
+
+		if (new_mtu > max_mtu) {
+				if (strict)
+						return -EINVAL;
+
+				new_mtu = max_mtu;
+		}
+
+		dev->mtu = new_mtu;
+		return 0;
+}
+
+static struct socket *gtp_create_sock(struct net *net, bool ipv6)
+{
+	struct socket *sock;
+	struct udp_port_cfg udp_conf;
+	int err;
+
+	memset(&udp_conf, 0, sizeof(udp_conf));
+
+	if (ipv6) {
+		udp_conf.family = AF_INET6;
+		udp_conf.ipv6_v6only = 1;
+	} else {
+		udp_conf.family = AF_INET;
+	}
+	udp_conf.local_ip.s_addr = htonl(INADDR_ANY);
+	udp_conf.local_udp_port = htons(GTP1U_PORT);
+
+	err = udp_sock_create(net, &udp_conf, &sock);
+	if (err < 0)
+		return ERR_PTR(err);
+
+	return sock;
+}
+
+
+static void gtp_setup_sock(struct gtp_dev *gtp,
+									 struct net *net,
+									 struct socket *sock)
+{
+	struct udp_tunnel_sock_cfg tunnel_cfg;
+
+	memset(&tunnel_cfg, 0, sizeof(tunnel_cfg));
+	tunnel_cfg.sk_user_data = gtp;
+	tunnel_cfg.encap_rcv = gtp_encap_recv;
+	tunnel_cfg.encap_destroy = gtp_encap_destroy;
+	tunnel_cfg.encap_type = UDP_ENCAP_GTP1U;
+
+	setup_udp_tunnel_sock(net, sock, &tunnel_cfg);
+
+	sock_hold(sock->sk);
+}
+
+
+static int gtp_dev_open(struct net_device *dev)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+	struct net *net = dev_net(dev);
+	struct socket *sock1u;
+	struct socket *sock1u_v6;
+
+	if (gtp->sk1u) {
+		sock_hold(gtp->sk1u);
+	} else {
+		sock1u = gtp_create_sock(net, false);
+		gtp_setup_sock(gtp, net, sock1u);
+		gtp->sk1u = sock1u->sk;
+	}
+
+	if (gtp->sk1u_v6) {
+		sock_hold(gtp->sk1u_v6);
+	} else {
+		sock1u_v6 = gtp_create_sock(net, true);
+		gtp_setup_sock(gtp, net, sock1u_v6);
+		gtp->sk1u_v6 = sock1u_v6->sk;
+	}
+
+	gtp->gtph_port = htons(GTP1U_PORT);
+
+	return 0;
+}
+
+static int gtp_dev_stop(struct net_device *dev)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+	struct sock *sk;
+
+	ASSERT_RTNL();
+	if (gtp->sk1u) {
+		sk = gtp->sk1u;
+
+		sock_put(sk);
+#ifdef HAVE_SOCK_REFCNT
+		if (refcount_read(&sk->sk_refcnt) == 2) {
+#else
+		if (atomic_read(&sk->sk_refcnt) == 2) {
+#endif
+			udp_tunnel_sock_release(gtp->sk1u->sk_socket);
+		}
+	}
+
+	if (gtp->sk1u_v6) {
+		sk = gtp->sk1u_v6;
+
+		sock_put(sk);
+#ifdef HAVE_SOCK_REFCNT
+		if (refcount_read(&sk->sk_refcnt) == 2) {
+#else
+		if (atomic_read(&sk->sk_refcnt) == 2) {
+#endif
+			udp_tunnel_sock_release(gtp->sk1u_v6->sk_socket);
+		}
+	}
+
+	return 0;
+}
+
+static const struct net_device_ops gtp_netdev_ops = {
+	.ndo_init		= gtp_dev_init,
+	.ndo_uninit		= gtp_dev_uninit,
+	.ndo_open               = gtp_dev_open,
+	.ndo_stop               = gtp_dev_stop,
+	.ndo_start_xmit		= gtp_dev_xmit,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        .ndo_get_stats64        = dev_get_tstats64,
+#else
+        .ndo_get_stats64        = ip_tunnel_get_stats64,
+#endif
+};
+
+static struct gtp_dev *gtp_find_flow_based_dev(
+		struct net *net)
+{
+	struct gtp_net *gn = net_generic(net, gtp_net_id);
+	struct gtp_dev *gtp, *t = NULL;
+
+	list_for_each_entry(gtp, &gn->gtp_dev_list, list) {
+		t = gtp;
+	}
+
+	return t;
+}
+
+static void gtp_link_setup(struct net_device *dev)
+{
+	dev->netdev_ops		= &gtp_netdev_ops;
+
+#ifdef HAVE_NEEDS_FREE_NETDEV
+	dev->needs_free_netdev	= true;
+#endif
+	dev->hard_header_len = 0;
+	dev->addr_len = 0;
+
+	/* Zero header length. */
+	dev->type = ARPHRD_NONE;
+	dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
+
+	dev->priv_flags	 |= IFF_NO_QUEUE;
+
+	dev->features    |= NETIF_F_LLTX;
+	dev->features    |= NETIF_F_SG | NETIF_F_HW_CSUM;
+	dev->features    |= NETIF_F_RXCSUM;
+	dev->features    |= NETIF_F_GSO_SOFTWARE;
+
+	dev->hw_features |= NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_RXCSUM;
+	dev->hw_features |= NETIF_F_GSO_SOFTWARE;
+
+
+	netif_keep_dst(dev);
+
+	dev->needed_headroom	= LL_MAX_HEADER +
+				  sizeof(struct iphdr) +
+				  sizeof(struct udphdr) +
+				  sizeof(struct gtp1_header);
+
+}
+
+#ifdef HAVE_EXT_ACK_IN_RTNL_LINKOPS
+static int gtp_newlink(struct net *src_net, struct net_device *dev,
+			   struct nlattr *tb[], struct nlattr *data[],
+			   struct netlink_ext_ack *extack)
+#else
+static int gtp_newlink(struct net *src_net, struct net_device *dev,
+			   struct nlattr *tb[], struct nlattr *data[])
+#endif
+{
+	struct gtp_dev *gtp;
+	struct gtp_net *gn;
+	int err;
+
+	gtp = netdev_priv(dev);
+
+	err = register_netdevice(dev);
+	if (err < 0) {
+		netdev_dbg(dev, "failed to register new netdev %d\n", err);
+		goto out_encap;
+	}
+
+	gn = net_generic(dev_net(dev), gtp_net_id);
+	list_add_rcu(&gtp->list, &gn->gtp_dev_list);
+	netdev_dbg(dev, "registered new GTP interface\n");
+
+	return 0;
+
+out_encap:
+	gtp_encap_disable(gtp);
+	return err;
+}
+
+static void gtp_hashtable_free(struct net_device *dev)
+{
+	struct gtp_dev *gtp = netdev_priv(dev);
+
+	list_del_rcu(&gtp->list);
+}
+
+static void gtp_dellink(struct net_device *dev, struct list_head *head)
+{
+	gtp_hashtable_free(dev);
+	unregister_netdevice_queue(dev, head);
+}
+
+#ifdef HAVE_EXT_ACK_IN_RTNL_LINKOPS
+static int gtp_validate(struct nlattr *tb[], struct nlattr *data[],
+			struct netlink_ext_ack *extack)
+#else
+static int gtp_validate(struct nlattr *tb[], struct nlattr *data[])
+#endif
+{
+	return 0;
+}
+
+static size_t gtp_get_size(const struct net_device *dev)
+{
+	return 0;
+}
+
+static int gtp_fill_info(struct sk_buff *skb, const struct net_device *dev)
+{
+	return 0;
+}
+
+static const struct nla_policy gtp_policy[IFLA_GTP_LWT_MAX + 1] = {
+};
+
+static struct rtnl_link_ops gtp_link_ops __read_mostly = {
+	.kind		= "ovs_gtp",
+	.maxtype	= IFLA_GTP_MAX,
+	.policy		= gtp_policy,
+	.priv_size	= sizeof(struct gtp_dev),
+	.setup		= gtp_link_setup,
+	.validate	= gtp_validate,
+	.newlink	= gtp_newlink,
+	.dellink	= gtp_dellink,
+	.get_size	= gtp_get_size,
+	.fill_info	= gtp_fill_info,
+};
+
+static int gtp_configure(struct net *net, struct net_device *dev)
+{
+	struct gtp_net *gn = net_generic(net, gtp_net_id);
+	struct gtp_dev *gtp = netdev_priv(dev);
+	int err;
+
+	gtp->dev = dev;
+
+	if (gtp_find_flow_based_dev(net))
+		return -EBUSY;
+
+	dev->netdev_ops         = &gtp_netdev_ops;
+
+	dev->hard_header_len = 0;
+	dev->addr_len = 0;
+
+	/* Zero header length. */
+	dev->type = ARPHRD_NONE;
+	dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
+
+	dev->priv_flags |= IFF_NO_QUEUE;
+	dev->features   |= NETIF_F_LLTX;
+	netif_keep_dst(dev);
+
+	dev->needed_headroom    = LL_MAX_HEADER +
+		sizeof(struct iphdr) +
+		sizeof(struct udphdr) +
+		sizeof(struct gtp0_header);
+
+	err = register_netdevice(dev);
+	if (err) {
+		pr_err("Error when registering net device");
+		return err;
+	}
+
+	list_add_rcu(&gtp->list, &gn->gtp_dev_list);
+	return 0;
+}
+
+struct net_device *rpl_gtp_create_flow_based_dev(struct net *net,
+		const char *name,
+		u8 name_assign_type,
+		u16 dst_port)
+{
+	struct nlattr *tb[IFLA_MAX + 1];
+	struct net_device *dev;
+	LIST_HEAD(list_kill);
+	int err;
+
+	memset(&tb, 0, sizeof(tb));
+	dev = rtnl_create_link(net, name, name_assign_type,
+			&gtp_link_ops, tb);
+	if (IS_ERR(dev)) {
+		pr_err("error rtnl_create_link");
+		return dev;
+	}
+
+	err = gtp_configure(net, dev);
+	if (err < 0) {
+		pr_err("error gtp_configure");
+		free_netdev(dev);
+		return ERR_PTR(err);
+	}
+
+	/* openvswitch users expect packet sizes to be unrestricted,
+	 * so set the largest MTU we can.
+	 */
+	err = gtp_change_mtu(dev, IP_MAX_MTU, false);
+	if (err) {
+		pr_err("error gtp_change_mtu");
+		goto err;
+	}
+
+	err = rtnl_configure_link(dev, NULL);
+	if (err < 0)  {
+		pr_err("error rtnl_configure_link");
+		goto err;
+	}
+
+	return dev;
+
+err:
+	gtp_dellink(dev, &list_kill);
+	unregister_netdevice_many(&list_kill);
+	return ERR_PTR(err);
+}
+EXPORT_SYMBOL_GPL(rpl_gtp_create_flow_based_dev);
+
+static int __net_init gtp_net_init(struct net *net)
+{
+	struct gtp_net *gn = net_generic(net, gtp_net_id);
+
+	INIT_LIST_HEAD(&gn->gtp_dev_list);
+	return 0;
+}
+
+static void __net_exit gtp_net_exit(struct net *net)
+{
+	struct gtp_net *gn = net_generic(net, gtp_net_id);
+	struct gtp_dev *gtp;
+	LIST_HEAD(list);
+
+	rtnl_lock();
+	list_for_each_entry(gtp, &gn->gtp_dev_list, list)
+		gtp_dellink(gtp->dev, &list);
+
+	unregister_netdevice_many(&list);
+	rtnl_unlock();
+}
+
+static struct pernet_operations gtp_net_ops = {
+	.init	= gtp_net_init,
+	.exit	= gtp_net_exit,
+	.id	= &gtp_net_id,
+	.size	= sizeof(struct gtp_net),
+};
+
+int rpl_gtp_init_module(void)
+{
+	int err;
+
+	err = rtnl_link_register(&gtp_link_ops);
+	if (err < 0)
+		goto error_out;
+
+	err = register_pernet_subsys(&gtp_net_ops);
+	if (err < 0)
+		goto unreg_rtnl_link;
+
+	pr_info("GTP-LWT module with tunnel metadata support\n");
+	return 0;
+
+unreg_rtnl_link:
+	rtnl_link_unregister(&gtp_link_ops);
+error_out:
+	pr_err("error loading GTP module loaded\n");
+	return err;
+}
+
+void rpl_gtp_cleanup_module(void)
+{
+	rtnl_link_unregister(&gtp_link_ops);
+	unregister_pernet_subsys(&gtp_net_ops);
+
+	pr_info("GTP-LWTmodule unloaded\n");
+}
diff --git a/datapath/linux/compat/include/linux/gtp.h b/datapath/linux/compat/include/linux/gtp.h
new file mode 100644
index 000000000..238a42905
--- /dev/null
+++ b/datapath/linux/compat/include/linux/gtp.h
@@ -0,0 +1,24 @@
+#ifndef _WRAPPER_UAPI_LINUX_GTP_H_
+#define _WRAPPER_UAPI_LINUX_GTP_H_
+
+#include_next <linux/gtp.h>
+
+#ifndef GTPA_PEER_ADDRESS
+#define GTPA_PEER_ADDRESS GTPA_SGSN_ADDRESS
+#endif
+
+enum {
+	GTP_METADATA_V1
+};
+
+struct gtpu_metadata {
+	__u8	ver;
+	__u8	flags;
+	__u8	type;
+	__u8    qfi;
+};
+
+enum {
+        IFLA_GTP_LWT_MAX
+};
+#endif
\ No newline at end of file
diff --git a/datapath/linux/compat/include/linux/if_link.h b/datapath/linux/compat/include/linux/if_link.h
index bd77e33d3..092d79468 100644
--- a/datapath/linux/compat/include/linux/if_link.h
+++ b/datapath/linux/compat/include/linux/if_link.h
@@ -168,4 +168,20 @@ struct rtnl_link_stats64 {
 };
 #endif
 
+#ifndef HAVE_GTP_ROLE_GGSN
+/* GTP section */
+
+enum ifla_gtp_role {
+        GTP_ROLE_GGSN = 0,
+        GTP_ROLE_SGSN,
+};
+#endif
+
+#ifndef HAVE_IFLA_GTP_ROLE
+
+enum {
+	IFLA_GTP_ROLE = (IFLA_GTP_PDP_HASHSIZE + 1)
+};
+#endif
+
 #endif
diff --git a/datapath/linux/compat/include/linux/openvswitch.h b/datapath/linux/compat/include/linux/openvswitch.h
index 8d9300091..a4b6944d1 100644
--- a/datapath/linux/compat/include/linux/openvswitch.h
+++ b/datapath/linux/compat/include/linux/openvswitch.h
@@ -421,10 +421,7 @@ enum ovs_tunnel_key_attr {
 	OVS_TUNNEL_KEY_ATTR_IPV6_DST,		/* struct in6_addr dst IPv6 address. */
 	OVS_TUNNEL_KEY_ATTR_PAD,
 	OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS,	/* struct erspan_metadata */
-#ifndef __KERNEL__
-	/* Only used within userspace data path. */
 	OVS_TUNNEL_KEY_ATTR_GTPU_OPTS,		/* struct gtpu_metadata */
-#endif
 	__OVS_TUNNEL_KEY_ATTR_MAX
 };
 
diff --git a/datapath/linux/compat/include/linux/skbuff.h b/datapath/linux/compat/include/linux/skbuff.h
index 396a5e406..e6de8e37e 100644
--- a/datapath/linux/compat/include/linux/skbuff.h
+++ b/datapath/linux/compat/include/linux/skbuff.h
@@ -261,10 +261,8 @@ static inline int skb_orphan_frags(struct sk_buff *skb, gfp_t gfp_mask)
 #define skb_get_hash skb_get_rxhash
 #endif /* HAVE_SKB_GET_HASH */
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
 #define skb_zerocopy_headlen rpl_skb_zerocopy_headlen
 unsigned int rpl_skb_zerocopy_headlen(const struct sk_buff *from);
-#endif
 
 #ifndef HAVE_SKB_ZEROCOPY
 #define skb_zerocopy rpl_skb_zerocopy
diff --git a/datapath/linux/compat/include/net/dst_cache.h b/datapath/linux/compat/include/net/dst_cache.h
index 6084d4eea..37c219e87 100644
--- a/datapath/linux/compat/include/net/dst_cache.h
+++ b/datapath/linux/compat/include/net/dst_cache.h
@@ -4,7 +4,6 @@
 #ifdef USE_BUILTIN_DST_CACHE
 #include_next <net/dst_cache.h>
 #else
-
 #include <linux/jiffies.h>
 #include <net/dst.h>
 #if IS_ENABLED(CONFIG_IPV6)
diff --git a/datapath/linux/compat/include/net/gtp.h b/datapath/linux/compat/include/net/gtp.h
new file mode 100644
index 000000000..2f68ebba6
--- /dev/null
+++ b/datapath/linux/compat/include/net/gtp.h
@@ -0,0 +1,24 @@
+#ifndef __NET_GTP_WRAPPER_H
+#define __NET_GTP_WRAPPER_H  1
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+#ifdef CONFIG_INET
+#include <net/udp_tunnel.h>
+#endif /* ifdef CONFIG_INET */
+
+#include_next <net/gtp.h>
+
+#define gtp_xmit dev_queue_xmit
+
+struct net_device *rpl_gtp_dev_create_fb(
+	struct net *net, const char *name, u8 name_assign_type, u16 dst_port);
+#define gtp_create_flow_based_dev rpl_gtp_create_flow_based_dev
+
+
+#define gtp_init_module rpl_gtp_init_module
+#define gtp_cleanup_module rpl_gtp_cleanup_module
+int rpl_gtp_init_module(void);
+void rpl_gtp_cleanup_module(void);
+
+#endif /* 4.7 kernel */
+#endif /* __NET_GTP_WRAPPER_H */
\ No newline at end of file
diff --git a/datapath/linux/compat/include/net/ip_tunnels.h b/datapath/linux/compat/include/net/ip_tunnels.h
index 617a753c7..4cfaa50c8 100644
--- a/datapath/linux/compat/include/net/ip_tunnels.h
+++ b/datapath/linux/compat/include/net/ip_tunnels.h
@@ -9,9 +9,6 @@
  * be used. Those needs to be explicitly defined in this header file. */
 #include_next <net/ip_tunnels.h>
 
-#ifndef TUNNEL_ERSPAN_OPT
-#define TUNNEL_ERSPAN_OPT	__cpu_to_be16(0x4000)
-#endif
 #define ovs_ip_tunnel_encap ip_tunnel_encap
 
 #ifndef HAVE_IP_TUNNEL_INFO_OPTS_SET_FLAGS
@@ -109,10 +106,11 @@ void rpl_ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,
 #define TUNNEL_VXLAN_OPT	__cpu_to_be16(0x1000)
 #define TUNNEL_NOCACHE		__cpu_to_be16(0x2000)
 #define TUNNEL_ERSPAN_OPT	__cpu_to_be16(0x4000)
+#define TUNNEL_GTPU_OPT		__cpu_to_be16(0x8000)
 
 #undef TUNNEL_OPTIONS_PRESENT
 #define TUNNEL_OPTIONS_PRESENT \
-		(TUNNEL_GENEVE_OPT | TUNNEL_VXLAN_OPT | TUNNEL_ERSPAN_OPT)
+		(TUNNEL_GENEVE_OPT | TUNNEL_VXLAN_OPT | TUNNEL_ERSPAN_OPT | TUNNEL_GTPU_OPT)
 
 struct tnl_ptk_info {
 	__be16 flags;
@@ -510,4 +508,12 @@ static inline int iptunnel_pull_offloads(struct sk_buff *skb)
 #define skb_is_encapsulated ovs_skb_is_encapsulated
 bool ovs_skb_is_encapsulated(struct sk_buff *skb);
 
+#ifndef TUNNEL_ERSPAN_OPT
+#define TUNNEL_ERSPAN_OPT	__cpu_to_be16(0x4000)
+#endif
+
+#ifndef TUNNEL_GTPU_OPT
+#define TUNNEL_GTPU_OPT          __cpu_to_be16(0x8000)
+#endif
+
 #endif /* __NET_IP_TUNNELS_H */
diff --git a/datapath/linux/compat/include/net/udp_tunnel.h b/datapath/linux/compat/include/net/udp_tunnel.h
index 6e4063359..2db7e1afb 100644
--- a/datapath/linux/compat/include/net/udp_tunnel.h
+++ b/datapath/linux/compat/include/net/udp_tunnel.h
@@ -203,6 +203,6 @@ static inline void ovs_udp_tun_rx_dst(struct metadata_dst *md_dst,
 	if (udp_hdr(skb)->check)
 		info->key.tun_flags |= TUNNEL_CSUM;
 }
-#endif /* USE_UPSTREAM_TUNNEL */
 
+#endif /* USE_UPSTREAM_TUNNEL */
 #endif
diff --git a/datapath/linux/compat/ip6_gre.c b/datapath/linux/compat/ip6_gre.c
index 3aa9844b3..a05e6637d 100644
--- a/datapath/linux/compat/ip6_gre.c
+++ b/datapath/linux/compat/ip6_gre.c
@@ -1425,7 +1425,11 @@ static const struct net_device_ops ip6gre_netdev_ops = {
 #else
 	.ndo_change_mtu		= ip6_tnl_change_mtu,
 #endif
-	.ndo_get_stats64	= ip_tunnel_get_stats64,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        .ndo_get_stats64        = dev_get_tstats64,
+#else
+        .ndo_get_stats64        = ip_tunnel_get_stats64,
+#endif
 #ifdef HAVE_NDO_GET_IFLINK
 	.ndo_get_iflink		= ip6_tnl_get_iflink,
 #endif
@@ -1917,7 +1921,11 @@ static const struct net_device_ops ip6gre_tap_netdev_ops = {
 #else
 	.ndo_change_mtu = ip6_tnl_change_mtu,
 #endif
-	.ndo_get_stats64 = ip_tunnel_get_stats64,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        .ndo_get_stats64        = dev_get_tstats64,
+#else
+        .ndo_get_stats64        = ip_tunnel_get_stats64,
+#endif
 #ifdef HAVE_NDO_GET_IFLINK
 	.ndo_get_iflink = ip6_tnl_get_iflink,
 #endif
@@ -1985,7 +1993,11 @@ static const struct net_device_ops ip6erspan_netdev_ops = {
 #else
 	.ndo_change_mtu =	ip6_tnl_change_mtu,
 #endif
-	.ndo_get_stats64 =	ip_tunnel_get_stats64,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        .ndo_get_stats64        = dev_get_tstats64,
+#else
+        .ndo_get_stats64        = ip_tunnel_get_stats64,
+#endif
 #ifdef HAVE_NDO_GET_IFLINK
 	.ndo_get_iflink =	ip6_tnl_get_iflink,
 #endif
diff --git a/datapath/linux/compat/ip_gre.c b/datapath/linux/compat/ip_gre.c
index c194ffe00..587d6376b 100644
--- a/datapath/linux/compat/ip_gre.c
+++ b/datapath/linux/compat/ip_gre.c
@@ -934,7 +934,11 @@ static const struct net_device_ops gre_tap_netdev_ops = {
 #else
 	.ndo_change_mtu		= ip_tunnel_change_mtu,
 #endif
-	.ndo_get_stats64	= ip_tunnel_get_stats64,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        .ndo_get_stats64        = dev_get_tstats64,
+#else
+        .ndo_get_stats64        = ip_tunnel_get_stats64,
+#endif
 #ifdef HAVE_NDO_GET_IFLINK
 	.ndo_get_iflink		= rpl_ip_tunnel_get_iflink,
 #endif
@@ -955,7 +959,11 @@ static const struct net_device_ops erspan_netdev_ops = {
 #else
 	.ndo_change_mtu		= ip_tunnel_change_mtu,
 #endif
-	.ndo_get_stats64	= ip_tunnel_get_stats64,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        .ndo_get_stats64        = dev_get_tstats64,
+#else
+        .ndo_get_stats64        = ip_tunnel_get_stats64,
+#endif
 #ifdef HAVE_NDO_GET_IFLINK
 	.ndo_get_iflink		= rpl_ip_tunnel_get_iflink,
 #endif
diff --git a/datapath/linux/compat/lisp.c b/datapath/linux/compat/lisp.c
index 49c60f4ed..09fdc7e98 100644
--- a/datapath/linux/compat/lisp.c
+++ b/datapath/linux/compat/lisp.c
@@ -24,6 +24,7 @@
 #include <linux/module.h>
 #include <linux/rculist.h>
 #include <linux/udp.h>
+#include <linux/ethtool.h>
 
 #include <net/icmp.h>
 #include <net/ip.h>
@@ -542,7 +543,11 @@ EXPORT_SYMBOL_GPL(ovs_lisp_fill_metadata_dst);
 static const struct net_device_ops lisp_netdev_ops = {
 	.ndo_init               = lisp_init,
 	.ndo_uninit             = lisp_uninit,
-	.ndo_get_stats64        = ip_tunnel_get_stats64,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        .ndo_get_stats64        = dev_get_tstats64,
+#else
+        .ndo_get_stats64        = ip_tunnel_get_stats64,
+#endif
 	.ndo_open               = lisp_open,
 	.ndo_stop               = lisp_stop,
 	.ndo_start_xmit         = lisp_dev_xmit,
diff --git a/datapath/linux/compat/nf_conntrack_reasm.c b/datapath/linux/compat/nf_conntrack_reasm.c
index 77b4b2548..debea478c 100644
--- a/datapath/linux/compat/nf_conntrack_reasm.c
+++ b/datapath/linux/compat/nf_conntrack_reasm.c
@@ -36,6 +36,7 @@
 #include <linux/random.h>
 #include <linux/slab.h>
 
+#include <net/ipv6_frag.h>
 #include <net/sock.h>
 #include <net/snmp.h>
 #include <net/inet_frag.h>
diff --git a/datapath/linux/compat/skbuff-openvswitch.c b/datapath/linux/compat/skbuff-openvswitch.c
index 4cdeedc58..9db943da1 100644
--- a/datapath/linux/compat/skbuff-openvswitch.c
+++ b/datapath/linux/compat/skbuff-openvswitch.c
@@ -19,7 +19,6 @@ void __skb_warn_lro_forwarding(const struct sk_buff *skb)
 
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
 
 static inline bool head_frag(const struct sk_buff *skb)
 {
@@ -40,9 +39,11 @@ rpl_skb_zerocopy_headlen(const struct sk_buff *from)
 
 	if (!head_frag(from) ||
 	    skb_headlen(from) < L1_CACHE_BYTES ||
-	    skb_shinfo(from)->nr_frags >= MAX_SKB_FRAGS)
+	    skb_shinfo(from)->nr_frags >= MAX_SKB_FRAGS) {
 		hlen = skb_headlen(from);
-
+                if (hlen == 0)
+                        hlen = from->len;
+        }
 	if (skb_has_frag_list(from))
 		hlen = from->len;
 
@@ -50,6 +51,7 @@ rpl_skb_zerocopy_headlen(const struct sk_buff *from)
 }
 EXPORT_SYMBOL_GPL(rpl_skb_zerocopy_headlen);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
 #ifndef HAVE_SKB_ZEROCOPY
 /**
  *	skb_zerocopy - Zero copy skb to skb
diff --git a/datapath/linux/compat/stt.c b/datapath/linux/compat/stt.c
index 39a294764..264eb2a8a 100644
--- a/datapath/linux/compat/stt.c
+++ b/datapath/linux/compat/stt.c
@@ -27,6 +27,7 @@
 #include <linux/skbuff.h>
 #include <linux/tcp.h>
 #include <linux/workqueue.h>
+#include <linux/ethtool.h>
 
 #include <net/dst_metadata.h>
 #include <net/icmp.h>
@@ -1837,7 +1838,11 @@ static const struct net_device_ops stt_netdev_ops = {
 	.ndo_open               = stt_open,
 	.ndo_stop               = stt_stop,
 	.ndo_start_xmit         = stt_dev_xmit,
-	.ndo_get_stats64        = ip_tunnel_get_stats64,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        .ndo_get_stats64        = dev_get_tstats64,
+#else
+        .ndo_get_stats64        = ip_tunnel_get_stats64,
+#endif
 #ifdef  HAVE_RHEL7_MAX_MTU
 	.ndo_size		= sizeof(struct net_device_ops),
 	.extended.ndo_change_mtu = stt_change_mtu,
diff --git a/datapath/linux/compat/udp_tunnel.c b/datapath/linux/compat/udp_tunnel.c
index 852069f62..349839b2b 100644
--- a/datapath/linux/compat/udp_tunnel.c
+++ b/datapath/linux/compat/udp_tunnel.c
@@ -14,6 +14,7 @@
 #include <net/net_namespace.h>
 #include <net/ip6_checksum.h>
 #include <net/ip6_tunnel.h>
+#include <net/dst_metadata.h>
 
 #include "gso.h"
 
@@ -288,5 +289,4 @@ void ovs_udp_csum_gso(struct sk_buff *skb)
 }
 EXPORT_SYMBOL_GPL(ovs_udp_csum_gso);
 #endif /* USE_UPSTREAM_TUNNEL_GSO */
-
 #endif
diff --git a/datapath/linux/compat/vxlan.c b/datapath/linux/compat/vxlan.c
index e65d955e9..4a38dc6ec 100644
--- a/datapath/linux/compat/vxlan.c
+++ b/datapath/linux/compat/vxlan.c
@@ -1537,7 +1537,11 @@ static const struct net_device_ops vxlan_netdev_ether_ops = {
 	.ndo_open		= vxlan_open,
 	.ndo_stop		= vxlan_stop,
 	.ndo_start_xmit		= vxlan_dev_xmit,
-	.ndo_get_stats64	= ip_tunnel_get_stats64,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        .ndo_get_stats64        = dev_get_tstats64,
+#else
+        .ndo_get_stats64        = ip_tunnel_get_stats64,
+#endif
 	.ndo_set_rx_mode	= vxlan_set_multicast_list,
 #ifdef	HAVE_RHEL7_MAX_MTU
 	.ndo_size		= sizeof(struct net_device_ops),
@@ -1558,7 +1562,11 @@ static const struct net_device_ops vxlan_netdev_raw_ops = {
 	.ndo_open		= vxlan_open,
 	.ndo_stop		= vxlan_stop,
 	.ndo_start_xmit		= vxlan_dev_xmit,
-	.ndo_get_stats64	= ip_tunnel_get_stats64,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        .ndo_get_stats64        = dev_get_tstats64,
+#else
+        .ndo_get_stats64        = ip_tunnel_get_stats64,
+#endif
 #ifdef	HAVE_RHEL7_MAX_MTU
 	.ndo_size		= sizeof(struct net_device_ops),
 	.extended.ndo_change_mtu = vxlan_change_mtu,
diff --git a/datapath/vport-gtp.c b/datapath/vport-gtp.c
new file mode 100644
index 000000000..4ff712e35
--- /dev/null
+++ b/datapath/vport-gtp.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2020 The Magma Authors.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/net.h>
+#include <linux/rculist.h>
+#include <linux/udp.h>
+#include <linux/if_vlan.h>
+#include <linux/module.h>
+
+#include <net/gtp.h>
+#include <net/icmp.h>
+#include <net/ip.h>
+#include <net/route.h>
+#include <net/udp.h>
+#include <net/xfrm.h>
+
+#include "datapath.h"
+#include "vport.h"
+#include "vport-netdev.h"
+
+extern struct net_device *gtp_create_flow_based_dev(struct net *net, const char *name,
+						u8 name_assign_type, u16 dst_port);
+
+static struct vport_ops ovs_gtp_vport_ops;
+/**
+ * struct gtp_port - Keeps track of open UDP ports
+ * @dst_port: destination port.
+ */
+struct gtp_port {
+    u16 port_no;
+};
+
+static inline struct gtp_port *gtp_vport(const struct vport *vport)
+{
+    return vport_priv(vport);
+}
+
+static int gtp_get_options(const struct vport *vport,
+                           struct sk_buff *skb)
+{
+    struct gtp_port *gtp_port = gtp_vport(vport);
+
+    if (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, gtp_port->port_no))
+        return -EMSGSIZE;
+    return 0;
+}
+
+static struct vport *gtp_tnl_create(const struct vport_parms *parms)
+{
+    struct net *net = ovs_dp_get_net(parms->dp);
+    struct nlattr *options = parms->options;
+    struct gtp_port *gtp_port;
+    struct net_device *dev;
+    struct vport *vport;
+    struct nlattr *a;
+    u16 dst_port;
+    int err;
+
+    if (!options) {
+        err = -EINVAL;
+        goto error;
+    }
+
+    a = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);
+    if (a && nla_len(a) == sizeof(u16)) {
+        dst_port = nla_get_u16(a);
+    } else {
+        /* Require destination port from userspace. */
+        err = -EINVAL;
+        goto error;
+    }
+
+    vport = ovs_vport_alloc(sizeof(struct gtp_port),
+                            &ovs_gtp_vport_ops, parms);
+    if (IS_ERR(vport))
+        return vport;
+
+    gtp_port = gtp_vport(vport);
+    gtp_port->port_no = dst_port;
+
+    rtnl_lock();
+    dev = gtp_create_flow_based_dev(net, parms->name, NET_NAME_USER, dst_port);
+    if (IS_ERR(dev)) {
+        rtnl_unlock();
+        ovs_vport_free(vport);
+        return ERR_CAST(dev);
+    }
+
+    err = dev_change_flags(dev, dev->flags | IFF_UP, NULL);
+    if (err < 0) {
+	rtnl_delete_link(dev);
+	rtnl_unlock();
+	ovs_vport_free(vport);
+	goto error;
+    }
+
+    rtnl_unlock();
+    return vport;
+error:
+    return ERR_PTR(err);
+}
+
+static struct vport *gtp_create(const struct vport_parms *parms)
+{
+    struct vport *vport;
+    vport = gtp_tnl_create(parms);
+    if (IS_ERR(vport))
+        return vport;
+
+    return ovs_netdev_link(vport, parms->name);
+}
+
+
+static struct vport_ops ovs_gtp_vport_ops = {
+    .type                = OVS_VPORT_TYPE_GTPU,
+    .create              = gtp_create,
+    .get_options         = gtp_get_options,
+    .destroy		 = ovs_netdev_tunnel_destroy,
+    .send                = gtp_xmit,
+};
+
+static int __init ovs_gtp_tnl_init(void)
+{
+    return ovs_vport_ops_register(&ovs_gtp_vport_ops);
+}
+
+static void __exit ovs_gtp_tnl_exit(void)
+{
+    ovs_vport_ops_unregister(&ovs_gtp_vport_ops);
+}
+
+module_init(ovs_gtp_tnl_init);
+module_exit(ovs_gtp_tnl_exit);
+
+MODULE_DESCRIPTION("OVS: GTP switching port");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("vport-type-110");
\ No newline at end of file
diff --git a/datapath/vport.c b/datapath/vport.c
index bd62c5612..d7352b644 100644
--- a/datapath/vport.c
+++ b/datapath/vport.c
@@ -33,6 +33,7 @@
 #include <net/lisp.h>
 #include <net/gre.h>
 #include <net/geneve.h>
+#include <net/gtp.h>
 #include <net/stt.h>
 #include <net/vxlan.h>
 
@@ -107,8 +108,12 @@ skip_ip6_tunnel_init:
 	err = ovs_stt_init_module();
 	if (err)
 		goto err_stt;
-
+	err = gtp_init_module();
+	if (err)
+		goto err_gtp;
+ 
 	return 0;
+err_gtp:
 	ovs_stt_cleanup_module();
 err_stt:
 	vxlan_cleanup_module();
@@ -136,6 +141,7 @@ err_lisp:
  */
 void ovs_vport_exit(void)
 {
+	gtp_cleanup_module();
 	if (compat_gre_loaded) {
 		gre_exit();
 		ipgre_fini();
@@ -552,6 +558,7 @@ int ovs_vport_receive(struct vport *vport, struct sk_buff *skb,
 		kfree_skb(skb);
 		return error;
 	}
+
 	ovs_dp_process_packet(skb, &key);
 	return 0;
 }
diff --git a/debian/ifupdown.sh b/debian/ifupdown.sh
index 01982acbf..26ae08b1b 100755
--- a/debian/ifupdown.sh
+++ b/debian/ifupdown.sh
@@ -77,9 +77,13 @@ if [ "${MODE}" = "start" ]; then
                     ${OVS_EXTRA+-- $OVS_EXTRA}
                 ;;
         OVSTunnel)
+                if [ "$IF_OVS_TUNNEL_TYPE" = "gtp" ]; then
+                    OVS_TUNNEL_TYPE="gtpu"
+                fi
+
                 ovs_vsctl -- --may-exist add-port "${IF_OVS_BRIDGE}"\
                     "${IFACE}" ${IF_OVS_OPTIONS} -- set Interface "${IFACE}" \
-                    type=${IF_OVS_TUNNEL_TYPE} ${IF_OVS_TUNNEL_OPTIONS} \
+                    type=${OVS_TUNNEL_TYPE} ${IF_OVS_TUNNEL_OPTIONS} \
                     ${OVS_EXTRA+-- $OVS_EXTRA}
                 ;;
         *)
diff --git a/include/openvswitch/match.h b/include/openvswitch/match.h
index 2e8812048..45c6ca5ba 100644
--- a/include/openvswitch/match.h
+++ b/include/openvswitch/match.h
@@ -300,6 +300,8 @@ char *minimatch_to_string(const struct minimatch *,
                           const struct ofputil_port_map *, int priority);
 
 bool minimatch_has_default_hidden_fields(const struct minimatch *);
+void match_set_qfi(struct match *, uint8_t qfi);
+void match_set_qfi_masked(struct match *, uint8_t qfi, uint8_t mask);
 
 #ifdef __cplusplus
 }
diff --git a/include/openvswitch/meta-flow.h b/include/openvswitch/meta-flow.h
index 3b0220aaa..b7142edbc 100644
--- a/include/openvswitch/meta-flow.h
+++ b/include/openvswitch/meta-flow.h
@@ -380,7 +380,7 @@ enum OVS_PACKED_ENUM mf_field_id {
      *
      * For non-tunneled packets, the value is 0.
      *
-     * Type: be16 (low 1 bits).
+     * Type: be16 (low 4 bits).
      * Maskable: bitwise.
      * Formatting: tunnel flags.
      * Prerequisites: none.
@@ -514,7 +514,7 @@ enum OVS_PACKED_ENUM mf_field_id {
      * Maskable: bitwise.
      * Formatting: hexadecimal.
      * Prerequisites: none.
-     * Access: read-only.
+     * Access: read/write.
      * NXM: none.
      * OXM: NXOXM_ET_GTPU_FLAGS(15) since v2.13.
      */
@@ -526,9 +526,9 @@ enum OVS_PACKED_ENUM mf_field_id {
      *
      * Type: u8.
      * Maskable: bitwise.
-     * Formatting: decimal.
+     * Formatting: hexadecimal.
      * Prerequisites: none.
-     * Access: read-only.
+     * Access: read/write.
      * NXM: none.
      * OXM: NXOXM_ET_GTPU_MSGTYPE(16) since v2.13.
      */
@@ -1960,6 +1960,23 @@ enum OVS_PACKED_ENUM mf_field_id {
      */
     MFF_NSH_TTL,
 
+    /* "qfi".
+     *
+     * The "qfi" in a packet received via a keyed
+     * tunnel. For non-keyed
+     * tunnels and packets not received via a tunnel, the value is 0.
+     *
+     * Type: u8.
+     * Maskable: bitwise.
+     * Formatting: hexadecimal.
+     * Prerequisites: none.
+     * Access: read/write.
+     * NXM: NXM_NX_QFI(126) since v1.1.
+     * OXM: OXM_OF_TUNNEL_QFI(46) since OF1.3 and v1.10.
+     * Prefix lookup member: tunnel.qfi.
+     */
+    MFF_QFI,
+
     MFF_N_IDS
 };
 
diff --git a/include/openvswitch/ofp-actions.h b/include/openvswitch/ofp-actions.h
index b7231c7bb..a0fde5177 100644
--- a/include/openvswitch/ofp-actions.h
+++ b/include/openvswitch/ofp-actions.h
@@ -95,6 +95,7 @@ struct vl_mff_map;
     OFPACT(POP_MPLS,        ofpact_pop_mpls,    ofpact, "pop_mpls")     \
     OFPACT(DEC_NSH_TTL,     ofpact_null,        ofpact, "dec_nsh_ttl")  \
     OFPACT(DELETE_FIELD,    ofpact_delete_field, ofpact, "delete_field") \
+    OFPACT(SET_TUNNEL_QFI,  ofpact_tun_qfi,      ofpact, "qfi")         \
                                                                         \
     /* Generic encap & decap */                                         \
     OFPACT(ENCAP,           ofpact_encap,       props, "encap")         \
@@ -654,6 +655,17 @@ struct ofpact_check_pkt_larger {
         uint16_t pkt_len;
     );
 };
+
+/* OFPACT_SET_TUN_QFI.
+ *
+ * Used for NXAST_SET_TUN_QFI. */
+struct ofpact_tun_qfi {
+    OFPACT_PADDED_MEMBERS(
+        struct ofpact ofpact;
+        uint8_t qfi;
+    );
+};
+
 /* OFPACT_WRITE_ACTIONS, OFPACT_CLONE.
  *
  * Used for OFPIT11_WRITE_ACTIONS, NXAST_CLONE. */
@@ -661,6 +673,7 @@ struct ofpact_nest {
     OFPACT_PADDED_MEMBERS(struct ofpact ofpact;);
     struct ofpact actions[];
 };
+
 BUILD_ASSERT_DECL(offsetof(struct ofpact_nest, actions) % OFPACT_ALIGNTO == 0);
 BUILD_ASSERT_DECL(offsetof(struct ofpact_nest, actions)
                   == sizeof(struct ofpact_nest));
@@ -1022,6 +1035,10 @@ struct ofpact_sample {
         uint32_t obs_point_id;
         ofp_port_t sampling_port;
         enum nx_action_sample_direction direction;
+        uint8_t msisdn[16];
+        struct eth_addr apn_mac_addr;
+        uint8_t apn_name[24];
+        uint64_t pdp_start_epoch;
     );
 };
 
diff --git a/include/openvswitch/packets.h b/include/openvswitch/packets.h
index a65cb0d04..54976188e 100644
--- a/include/openvswitch/packets.h
+++ b/include/openvswitch/packets.h
@@ -45,7 +45,8 @@ struct flow_tnl {
     uint8_t erspan_hwid;
     uint8_t gtpu_flags;
     uint8_t gtpu_msgtype;
-    uint8_t pad1[4];     /* Pad to 64 bits. */
+    uint8_t qfi;
+    uint8_t pad1[3];     /* Pad to 64 bits. */
     struct tun_metadata metadata;
 };
 
@@ -55,9 +56,7 @@ struct flow_tnl {
 /* Public flags */
 #define FLOW_TNL_F_OAM (1 << 0)
 
-#define FLOW_TNL_PUB_F_MASK ((1 << 1) - 1)
-
-/* Private flags */
+#define FLOW_TNL_PUB_F_MASK ((1 << 4) - 1)
 #define FLOW_TNL_F_DONT_FRAGMENT (1 << 1)
 #define FLOW_TNL_F_CSUM (1 << 2)
 #define FLOW_TNL_F_KEY (1 << 3)
@@ -95,6 +94,23 @@ struct ovs_key_nsh {
 
 #define FLOW_NSH_F_MASK ((1 << 2) - 1)
 
+/* GTP protocol stuff used by userspace. */
+struct gtp1_cntr_echo_req_header {
+    ovs_be16	    seq;
+    // we do not need rest of header.
+} __attribute__ ((packed));
+
+struct gtpv1_tlv {
+    uint8_t type;
+    uint8_t value;
+}__attribute__ ((packed));
+
+struct gtp1_cntr_echo_rsp_header {
+    ovs_be16	        seq;
+    struct gtpv1_tlv    unused;
+    struct gtpv1_tlv    recovery;
+} __attribute__ ((packed));
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/bfd.c b/lib/bfd.c
index 9698576d0..359ebd1be 100644
--- a/lib/bfd.c
+++ b/lib/bfd.c
@@ -15,6 +15,7 @@
 #include <config.h>
 #include "bfd.h"
 
+#include <errno.h>
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
@@ -359,7 +360,7 @@ bfd_configure(struct bfd *bfd, const char *name, const struct smap *cfg,
     int decay_min_rx;
     long long int min_tx, min_rx;
     bool need_poll = false;
-    bool cfg_min_rx_changed = false;
+    bool cfg_min_rx_changed = false, dummy1=false;
     bool cpath_down, forwarding_if_rx;
 
     if (!cfg || !smap_get_bool(cfg, "enable", false)) {
@@ -478,6 +479,9 @@ bfd_configure(struct bfd *bfd, const char *name, const struct smap *cfg,
         bfd_forwarding_if_rx_update(bfd);
     }
 
+    if (netdev_should_send_keep_alive_pkt(bfd->netdev, &dummy1) != EOPNOTSUPP) {
+        need_poll = true;
+    }
     if (need_poll) {
         bfd_poll(bfd);
     }
@@ -522,6 +526,7 @@ long long int
 bfd_wake_time(const struct bfd *bfd) OVS_EXCLUDED(mutex)
 {
     long long int retval;
+    bool ret;
 
     if (!bfd) {
         return LLONG_MAX;
@@ -531,9 +536,14 @@ bfd_wake_time(const struct bfd *bfd) OVS_EXCLUDED(mutex)
     if (bfd->flags & FLAG_FINAL) {
         retval = 0;
     } else {
-        retval = bfd->next_tx;
-        if (bfd->state > STATE_DOWN) {
-            retval = MIN(bfd->detect_time, retval);
+        if (netdev_should_send_keep_alive_pkt(bfd->netdev, &ret) != EOPNOTSUPP) {
+            // do not change time interval for keep alive
+            retval =  time_msec() + bfd_tx_interval(bfd);
+        } else {
+            retval = bfd->next_tx;
+            if (bfd->state > STATE_DOWN) {
+                retval = MIN(bfd->detect_time, retval);
+            }
         }
     }
     ovs_mutex_unlock(&mutex);
@@ -547,6 +557,11 @@ bfd_run(struct bfd *bfd) OVS_EXCLUDED(mutex)
     bool old_in_decay;
 
     ovs_mutex_lock(&mutex);
+    bool ret;
+    if (netdev_should_send_keep_alive_pkt(bfd->netdev, &ret) != EOPNOTSUPP) {
+        goto unlock;
+    }
+ 
     now = time_msec();
     old_in_decay = bfd->in_decay;
 
@@ -567,6 +582,7 @@ bfd_run(struct bfd *bfd) OVS_EXCLUDED(mutex)
         || bfd->in_decay != old_in_decay) {
         bfd_poll(bfd);
     }
+unlock:
     ovs_mutex_unlock(&mutex);
 }
 
@@ -575,20 +591,26 @@ bfd_should_send_packet(const struct bfd *bfd) OVS_EXCLUDED(mutex)
 {
     bool ret;
     ovs_mutex_lock(&mutex);
-    ret = bfd->flags & FLAG_FINAL || time_msec() >= bfd->next_tx;
+    if (netdev_should_send_keep_alive_pkt(bfd->netdev, &ret) != EOPNOTSUPP) {
+        ret = (bfd->flags & FLAG_FINAL) || ret;
+    } else {
+        ret = bfd->flags & FLAG_FINAL || time_msec() >= bfd->next_tx;
+    }
     ovs_mutex_unlock(&mutex);
     return ret;
 }
 
-void
+int
 bfd_put_packet(struct bfd *bfd, struct dp_packet *p,
-               const struct eth_addr eth_src, bool *oam) OVS_EXCLUDED(mutex)
+               const struct eth_addr eth_src, struct ofpbuf *ofpacts) OVS_EXCLUDED(mutex)
 {
     long long int min_tx, min_rx;
     struct udp_header *udp;
     struct eth_header *eth;
     struct ip_header *ip;
     struct msg *msg;
+    bool more_pkts = false;
+    int ret;
 
     ovs_mutex_lock(&mutex);
     if (bfd->next_tx) {
@@ -613,6 +635,25 @@ bfd_put_packet(struct bfd *bfd, struct dp_packet *p,
         ? eth_addr_bfd : bfd->local_eth_dst;
     eth->eth_type = htons(ETH_TYPE_IP);
 
+    ret = netdev_build_keep_alive_pkt(bfd->netdev, p, ofpacts, &more_pkts);
+    VLOG_DBG("%s ret %d more_pkts %d\n",__func__, (int)ret, (int) more_pkts);
+    if (ret != EOPNOTSUPP) {
+        if (ret == 0) {
+                if (more_pkts == false) {
+                    bfd->flags &= ~FLAG_FINAL;
+                }
+                VLOG_DBG("%s: Sending GTP echo packet", bfd->name);
+                goto send_pkt;
+        }
+        // error
+        if (ret == ENOENT) {
+            bfd->flags &= ~FLAG_FINAL;
+        }
+        VLOG_DBG("%s could not build keep alive packet: %d \n",__func__, ret);
+        goto unlock;
+    }
+
+    ret = 0;
     ip = dp_packet_put_zeros(p, sizeof *ip);
     ip->ip_ihl_ver = IP_IHL_VER(5, 4);
     ip->ip_tot_len = htons(sizeof *ip + sizeof *udp + sizeof *msg);
@@ -651,13 +692,20 @@ bfd_put_packet(struct bfd *bfd, struct dp_packet *p,
     put_16aligned_be32(&msg->min_rx, htonl(min_rx * 1000));
 
     bfd->flags &= ~FLAG_FINAL;
-    *oam = bfd->oam;
-
+    if (bfd->oam) {
+        const ovs_be16 flag = htons(NX_TUN_FLAG_OAM);
+        ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_FLAGS),
+                              &flag, &flag);
+    }
     log_msg(VLL_DBG, msg, "Sending BFD Message", bfd);
 
+send_pkt:
+
     bfd->last_tx = time_msec();
     bfd_set_next_tx(bfd);
+unlock:
     ovs_mutex_unlock(&mutex);
+    return ret;
 }
 
 bool
@@ -665,6 +713,14 @@ bfd_should_process_flow(const struct bfd *bfd_, const struct flow *flow,
                         struct flow_wildcards *wc)
 {
     struct bfd *bfd = CONST_CAST(struct bfd *, bfd_);
+    bool res;
+
+    if (!netdev_is_keep_alive_pkt(bfd->netdev, flow, wc, &res)) {
+        if (res) {
+            bfd->flags |= FLAG_FINAL;
+        }
+        return res;
+    }
 
     if (!eth_addr_is_zero(bfd->rmt_eth_dst)) {
         memset(&wc->masks.dl_dst, 0xff, sizeof wc->masks.dl_dst);
@@ -709,15 +765,21 @@ bfd_process_packet(struct bfd *bfd, const struct flow *flow,
     enum flags flags;
     uint8_t version;
     struct msg *msg;
-    const uint8_t *l7 = dp_packet_get_udp_payload(p);
+    const uint8_t *l7;
 
+    ovs_mutex_lock(&mutex);
+    if (netdev_process_keep_alive_pkt(bfd->netdev, flow, p) == 0) {
+        VLOG_DBG_RL(&rl, "%s: Received GTP echo packet", bfd->name);
+        goto unlock;
+    }
+
+    l7 = dp_packet_get_udp_payload(p);
     if (!l7) {
-        return; /* No UDP payload. */
+        goto unlock;     /* No UDP payload. */
     }
 
     /* This function is designed to follow section RFC 5880 6.8.6 closely. */
 
-    ovs_mutex_lock(&mutex);
     /* Increments the decay rx counter. */
     bfd->decay_rx_ctl++;
 
@@ -727,7 +789,6 @@ bfd_process_packet(struct bfd *bfd, const struct flow *flow,
         /* XXX Should drop in the kernel to prevent DOS. */
         goto out;
     }
-
     msg = dp_packet_at(p, l7 - (uint8_t *)dp_packet_data(p), BFD_PACKET_LEN);
     if (!msg) {
         VLOG_INFO_RL(&rl, "%s: Received too-short BFD control message (only "
@@ -889,6 +950,7 @@ bfd_process_packet(struct bfd *bfd, const struct flow *flow,
 
 out:
     bfd_forwarding__(bfd);
+unlock:
     ovs_mutex_unlock(&mutex);
 }
 
@@ -967,6 +1029,16 @@ bfd_in_poll(const struct bfd *bfd) OVS_REQUIRES(mutex)
 static void
 bfd_poll(struct bfd *bfd) OVS_REQUIRES(mutex)
 {
+    bool ret;
+    if (netdev_should_send_keep_alive_pkt(bfd->netdev, &ret) != EOPNOTSUPP) {
+        bfd_set_state(bfd, STATE_UP, DIAG_RMT_DOWN);
+        bfd->forwarding_override = 1;
+        bfd->rmt_state = STATE_UP;
+        bfd->poll_min_tx = bfd->cfg_min_tx;
+        bfd->min_tx = bfd->cfg_min_tx;
+        VLOG_DBG_RL(&rl, "%s: No Poll. Set State UP", bfd->name);
+        return;
+    }
     if (bfd->state > STATE_DOWN && !bfd_in_poll(bfd)
         && !(bfd->flags & FLAG_FINAL)) {
         bfd->poll_min_tx = bfd->cfg_min_tx;
diff --git a/lib/bfd.h b/lib/bfd.h
index 9d32327fb..fcbd8554d 100644
--- a/lib/bfd.h
+++ b/lib/bfd.h
@@ -35,8 +35,8 @@ long long int bfd_wait(const struct bfd *);
 void bfd_run(struct bfd *);
 
 bool bfd_should_send_packet(const struct bfd *);
-void bfd_put_packet(struct bfd *bfd, struct dp_packet *packet,
-                    const struct eth_addr eth_src, bool *oam);
+int bfd_put_packet(struct bfd *bfd, struct dp_packet *packet,
+                    const struct eth_addr eth_src, struct ofpbuf *ofpacts);
 
 bool bfd_should_process_flow(const struct bfd *, const struct flow *,
                              struct flow_wildcards *);
diff --git a/lib/dpif-netlink.c b/lib/dpif-netlink.c
index 6f2c7bc90..2f2b2ed5b 100644
--- a/lib/dpif-netlink.c
+++ b/lib/dpif-netlink.c
@@ -2859,8 +2859,7 @@ parse_odp_packet(struct ofpbuf *buf, struct dpif_upcall *upcall,
 {
     static const struct nl_policy ovs_packet_policy[] = {
         /* Always present. */
-        [OVS_PACKET_ATTR_PACKET] = { .type = NL_A_UNSPEC,
-                                     .min_len = ETH_HEADER_LEN },
+        [OVS_PACKET_ATTR_PACKET] = { .type = NL_A_UNSPEC },
         [OVS_PACKET_ATTR_KEY] = { .type = NL_A_NESTED },
 
         /* OVS_PACKET_CMD_ACTION only. */
diff --git a/lib/flow.c b/lib/flow.c
index 418c3c4f4..083719387 100644
--- a/lib/flow.c
+++ b/lib/flow.c
@@ -1293,6 +1293,9 @@ flow_get_metadata(const struct flow *flow, struct match *flow_metadata)
     if (flow->tunnel.gtpu_msgtype) {
         match_set_tun_gtpu_msgtype(flow_metadata, flow->tunnel.gtpu_msgtype);
     }
+    if (flow->tunnel.qfi) {
+        match_set_qfi(flow_metadata, flow->tunnel.qfi);
+    }
     tun_metadata_get_fmd(&flow->tunnel, flow_metadata);
     if (flow->metadata != htonll(0)) {
         match_set_metadata(flow_metadata, flow->metadata);
@@ -1856,6 +1859,9 @@ flow_wildcards_init_for_packet(struct flow_wildcards *wc,
         WC_MASK_FIELD(wc, tunnel.erspan_hwid);
         WC_MASK_FIELD(wc, tunnel.gtpu_flags);
         WC_MASK_FIELD(wc, tunnel.gtpu_msgtype);
+        if (flow->tunnel.qfi) {
+            WC_MASK_FIELD(wc, tunnel.qfi);
+        }
 
         if (!(flow->tunnel.flags & FLOW_TNL_F_UDPIF)) {
             if (flow->tunnel.metadata.present.map) {
diff --git a/lib/match.c b/lib/match.c
index 0b9dc4278..6dc3c2fe3 100644
--- a/lib/match.c
+++ b/lib/match.c
@@ -1398,6 +1398,9 @@ format_flow_tunnel(struct ds *s, const struct match *match)
                             FLOW_TNL_F_MASK);
         ds_put_char(s, ',');
     }
+    if (wc->masks.tunnel.qfi) {
+        ds_put_format(s, "qfi=%"PRIu8",", tnl->qfi);
+    }
     tun_metadata_match_format(s, match);
 }
 
@@ -1976,3 +1979,17 @@ minimatch_has_default_hidden_fields(const struct minimatch *m)
     return (minimatch_has_default_recirc_id(m)
             && minimatch_has_default_dp_hash(m));
 }
+
+void
+match_set_qfi(struct match *match, uint8_t qfi)
+{
+   match_set_qfi_masked(match, qfi, UINT8_MAX);
+}
+
+
+void
+match_set_qfi_masked(struct match *match, uint8_t qfi, uint8_t mask)
+{
+    match->wc.masks.tunnel.qfi = mask;
+    match->flow.tunnel.qfi = qfi & mask;
+}
\ No newline at end of file
diff --git a/lib/meta-flow.c b/lib/meta-flow.c
index 474344194..5781218ee 100644
--- a/lib/meta-flow.c
+++ b/lib/meta-flow.c
@@ -273,6 +273,8 @@ mf_is_all_wild(const struct mf_field *mf, const struct flow_wildcards *wc)
         return ipv6_mask_is_any(&wc->masks.ct_ipv6_src);
     case MFF_CT_IPV6_DST:
         return ipv6_mask_is_any(&wc->masks.ct_ipv6_dst);
+    case MFF_QFI:
+        return !wc->masks.tunnel.qfi;
     CASE_MFF_REGS:
         return !wc->masks.regs[mf->id - MFF_REG0];
     CASE_MFF_XREGS:
@@ -584,6 +586,7 @@ mf_is_value_valid(const struct mf_field *mf, const union mf_value *value)
     case MFF_ND_TLL:
     case MFF_ND_RESERVED:
     case MFF_ND_OPTIONS_TYPE:
+    case MFF_QFI:
         return true;
 
     case MFF_IN_PORT_OXM:
@@ -723,6 +726,9 @@ mf_get_value(const struct mf_field *mf, const struct flow *flow,
     case MFF_TUN_GTPU_MSGTYPE:
         value->u8 = flow->tunnel.gtpu_msgtype;
         break;
+    case MFF_QFI:
+        value->u8 = flow->tunnel.qfi;
+        break;
     CASE_MFF_TUN_METADATA:
         tun_metadata_read(&flow->tunnel, mf, value);
         break;
@@ -1060,6 +1066,9 @@ mf_set_value(const struct mf_field *mf,
     case MFF_TUN_GTPU_MSGTYPE:
         match_set_tun_gtpu_msgtype(match, value->u8);
         break;
+    case MFF_QFI:
+        match_set_qfi(match, value->u8);
+        break;
     CASE_MFF_TUN_METADATA:
         tun_metadata_set_match(mf, value, NULL, match, err_str);
         break;
@@ -1477,6 +1486,9 @@ mf_set_flow_value(const struct mf_field *mf,
     case MFF_TUN_ERSPAN_HWID:
         flow->tunnel.erspan_hwid = value->u8;
         break;
+    case MFF_QFI:
+        flow->tunnel.qfi = value->u8;
+        break;
     case MFF_TUN_GTPU_FLAGS:
         flow->tunnel.gtpu_flags = value->u8;
         break;
@@ -1827,6 +1839,7 @@ mf_is_pipeline_field(const struct mf_field *mf)
     CASE_MFF_XREGS:
     CASE_MFF_XXREGS:
     case MFF_PACKET_TYPE:
+    case MFF_QFI:
         return true;
 
     case MFF_DP_HASH:
@@ -2015,6 +2028,9 @@ mf_set_wild(const struct mf_field *mf, struct match *match, char **err_str)
     case MFF_TUN_GTPU_MSGTYPE:
         match_set_tun_gtpu_msgtype_masked(match, 0, 0);
         break;
+    case MFF_QFI:
+        match_set_qfi_masked(match, 0, 0);
+        break;
     CASE_MFF_TUN_METADATA:
         tun_metadata_set_match(mf, NULL, NULL, match, err_str);
         break;
@@ -2422,6 +2438,9 @@ mf_set(const struct mf_field *mf,
     case MFF_TUN_GTPU_MSGTYPE:
         match_set_tun_gtpu_msgtype_masked(match, value->u8, mask->u8);
         break;
+    case MFF_QFI:
+        match_set_qfi_masked(match, value->u8, mask->u8);
+        break;
     CASE_MFF_TUN_METADATA:
         tun_metadata_set_match(mf, value, mask, match, err_str);
         break;
diff --git a/lib/meta-flow.xml b/lib/meta-flow.xml
index ff81fddc5..175271153 100644
--- a/lib/meta-flow.xml
+++ b/lib/meta-flow.xml
@@ -1601,6 +1601,15 @@ ovs-ofctl add-flow br-int 'in_port=3,tun_src=192.168.1.1,tun_id=5001 actions=1'
       </diagram>
     </field>
 
+    <field id="MFF_QFI" title="qfi">
+      <p>
+        When a packet is received from a tunnel, this field is the
+        source address in the outer IP header of the tunneled packet.
+        This field is zero if the packet was not received over a
+        tunnel.
+      </p>
+    </field>
+
     <field id="MFF_TUN_IPV6_SRC" title="Tunnel IPv6 Source">
       Similar to <ref field="tun_src"/>, but for tunnels over IPv6.
     </field>
@@ -1876,6 +1885,17 @@ ovs-ofctl add-flow br-int 'in_port=3,tun_src=192.168.1.1,tun_id=5001 actions=1'
       The complete range of message types can be referred to [3GPP TS 29.281].
     </field>
 
+    <h2>GTP Fields</h2>
+
+    <field id="MFF_TUN_GTPU_MSGTYPE" title="Message type of GTP control plane packet">
+      This field is typically used to generate GTP Echo request response packets.
+    </field>
+
+    <field id="MFF_TUN_GTPU_FLAGS" title="GTP control plane packet flags">
+      GTP-C packets needs sequence number. This field allows controller to set it.
+    </field>
+
+
     <h2>Geneve Fields</h2>
 
     <p>
diff --git a/lib/netdev-native-tnl.c b/lib/netdev-native-tnl.c
index 6c9094638..03fcbb08c 100644
--- a/lib/netdev-native-tnl.c
+++ b/lib/netdev-native-tnl.c
@@ -328,6 +328,9 @@ udp_build_header(const struct netdev_tunnel_config *tnl_cfg,
 
     udp = netdev_tnl_ip_build_header(data, params, IPPROTO_UDP);
     udp->udp_dst = tnl_cfg->dst_port;
+    if (!tnl_cfg->gtp_random_src_port) {
+        udp->udp_src = tnl_cfg->dst_port;
+    }
 
     if (params->is_ipv6 || params->flow->tunnel.flags & FLOW_TNL_F_CSUM) {
         /* Write a value in now to mark that we should compute the checksum
@@ -770,6 +773,7 @@ netdev_gtpu_push_header(const struct netdev *netdev,
                         const struct ovs_action_push_tnl *data)
 {
     struct netdev_vport *dev = netdev_vport_cast(netdev);
+    struct netdev_tunnel_config *tnl_cfg;
     struct udp_header *udp;
     struct gtpuhdr *gtpuh;
     int ip_tot_size;
@@ -778,18 +782,21 @@ netdev_gtpu_push_header(const struct netdev *netdev,
     payload_len = dp_packet_size(packet);
     udp = netdev_tnl_push_ip_header(packet, data->header,
                                     data->header_len, &ip_tot_size);
-    udp->udp_src = netdev_tnl_get_src_port(packet);
-    udp->udp_len = htons(ip_tot_size);
-    netdev_tnl_calc_udp_csum(udp, packet, ip_tot_size);
-
     gtpuh = ALIGNED_CAST(struct gtpuhdr *, udp + 1);
 
+    tnl_cfg = &dev->tnl_cfg;
     if (gtpuh->md.flags & GTPU_S_MASK) {
         ovs_be16 *seqno = ALIGNED_CAST(ovs_be16 *, gtpuh + 1);
         *seqno = htons(atomic_count_inc(&dev->gre_seqno));
         payload_len += sizeof(struct gtpuhdr_opt);
     }
     gtpuh->len = htons(payload_len);
+
+    if (tnl_cfg->gtp_random_src_port) {
+        udp->udp_src = netdev_tnl_get_src_port(packet);
+    }
+    udp->udp_len = htons(ip_tot_size);
+
 }
 
 int
@@ -807,9 +814,9 @@ netdev_gtpu_build_header(const struct netdev *netdev,
 
     /* Set to default if not set in flow. */
     gtph->md.flags = params->flow->tunnel.gtpu_flags ?
-                     params->flow->tunnel.gtpu_flags : GTPU_FLAGS_DEFAULT;
+                  params->flow->tunnel.gtpu_flags : GTPU_FLAGS_DEFAULT;
     gtph->md.msgtype = params->flow->tunnel.gtpu_msgtype ?
-                       params->flow->tunnel.gtpu_msgtype : GTPU_MSGTYPE_GPDU;
+                    params->flow->tunnel.gtpu_msgtype : GTPU_MSGTYPE_GPDU;
     put_16aligned_be32(&gtph->teid,
                        be64_to_be32(params->flow->tunnel.tun_id));
 
diff --git a/lib/netdev-provider.h b/lib/netdev-provider.h
index b5420947d..5de0a4c73 100644
--- a/lib/netdev-provider.h
+++ b/lib/netdev-provider.h
@@ -837,6 +837,14 @@ struct netdev_class {
     /* Get a block_id from the netdev.
      * Returns the block_id or 0 if none exists for netdev. */
     uint32_t (*get_block_id)(struct netdev *);
+
+    int (*should_send_keep_alive_pkt) (struct netdev *, bool *res);
+    int (*is_keep_alive_pkt) (struct netdev *, const struct flow *flow,
+                               struct flow_wildcards *wc, bool *res);
+    int  (*process_keep_alive_pkt) (struct netdev *, const struct flow *flow,
+                               const struct dp_packet *p);
+    int (*build_keep_alive_pkt) (struct netdev *, struct dp_packet *p,
+                                struct ofpbuf *ofpacts, bool *more_pkts);
 };
 
 int netdev_register_provider(const struct netdev_class *);
diff --git a/lib/netdev-vport.c b/lib/netdev-vport.c
index aef8cf6a9..2c7da866f 100644
--- a/lib/netdev-vport.c
+++ b/lib/netdev-vport.c
@@ -29,6 +29,7 @@
 #include <sys/ioctl.h>
 
 #include "byte-order.h"
+#include "csum.h"
 #include "daemon.h"
 #include "dirs.h"
 #include "dpif.h"
@@ -36,6 +37,7 @@
 #include "netdev-native-tnl.h"
 #include "netdev-provider.h"
 #include "netdev-vport-private.h"
+#include "odp-util.h"
 #include "openvswitch/dynamic-string.h"
 #include "ovs-atomic.h"
 #include "ovs-router.h"
@@ -597,11 +599,13 @@ set_tunnel_config(struct netdev *dev_, const struct smap *args, char **errp)
     int err;
 
     has_csum = strstr(type, "gre") || strstr(type, "geneve") ||
-               strstr(type, "stt") || strstr(type, "vxlan");
+               strstr(type, "stt") || strstr(type, "vxlan") ||
+               strstr(type, "gtpu");
     has_seq = strstr(type, "gre");
     memset(&tnl_cfg, 0, sizeof tnl_cfg);
 
     /* Add a default destination port for tunnel ports if none specified. */
+    tnl_cfg.gtp_random_src_port = true;
     if (!strcmp(type, "geneve")) {
         tnl_cfg.dst_port = htons(GENEVE_DST_PORT);
     }
@@ -620,11 +624,11 @@ set_tunnel_config(struct netdev *dev_, const struct smap *args, char **errp)
 
     if (!strcmp(type, "gtpu")) {
         tnl_cfg.dst_port = htons(GTPU_DST_PORT);
+        tnl_cfg.gtp_random_src_port = false;
     }
 
     needs_dst_port = netdev_vport_needs_dst_port(dev_);
     tnl_cfg.dont_fragment = true;
-
     SMAP_FOR_EACH (node, args) {
         if (!strcmp(node->key, "remote_ip")) {
             err = parse_tunnel_ip(node->value, false, &tnl_cfg.ip_dst_flow,
@@ -669,10 +673,15 @@ set_tunnel_config(struct netdev *dev_, const struct smap *args, char **errp)
             }
         } else if (!strcmp(node->key, "dst_port") && needs_dst_port) {
             tnl_cfg.dst_port = htons(atoi(node->value));
+        } else if (!strcmp(node->key, "gtp_random_src_port") && !strcmp(type, "gtpu")) {
+            if (!strcmp(node->value, "true")) {
+                tnl_cfg.gtp_random_src_port = true;
+            }
         } else if (!strcmp(node->key, "csum") && has_csum) {
             if (!strcmp(node->value, "true")) {
                 tnl_cfg.csum = true;
             }
+            tnl_cfg.user_setcsum = true;
         } else if (!strcmp(node->key, "seq") && has_seq) {
             if (!strcmp(node->value, "true")) {
                 tnl_cfg.set_seq = true;
@@ -1171,6 +1180,178 @@ netdev_vport_get_pt_mode(const struct netdev *netdev)
 
 
 #ifdef __linux__
+
+static void
+gtp_get_remote_info(struct netdev_vport *dev, struct ds *ds)
+{
+    struct netdev_tunnel_config *cfg = &dev->tnl_cfg;
+    if (cfg && cfg->gtp_timestamp) {
+        ds_put_format(ds, "\t%s: RX: %ld TX: %ld remote ip: "IP_FMT", seq %d, pending send %d\n",
+                      xastrftime_msec("%H:%M:%S.###", cfg->gtp_timestamp, true), cfg->gtp_rx_cnt, cfg->gtp_tx_cnt,
+                      IP_ARGS(in6_addr_get_mapped_ipv4(&cfg->ipv6_dst)), cfg->gtp_seq, (int)cfg->gtp_need_to_send);
+    }
+}
+
+/* This function is for packet TX.
+ * currently we do not support sending keep alive packets. */
+static int gtp_should_send_keep_alive_pkt(struct netdev *netdev OVS_UNUSED, bool *res)
+{
+    *res = false;
+    return 0;
+}
+
+static int
+gtp_is_keep_alive_pkt(struct netdev *netdev, const struct flow *flow,
+                      struct flow_wildcards *wc, bool *res)
+{
+    //struct netdev_vport *dev = netdev_vport_cast(netdev);
+   
+  //aniket
+    const struct netdev_tunnel_config *tnl_cfg;
+
+    tnl_cfg = netdev_get_tunnel_config(netdev);
+    VLOG_DBG("gtpu flags %x msg_type %d dev->tnl_cfg.dst_port %d == (%d, %d) flow "IP_FMT" cfg "IP_FMT,
+            flow->tunnel.gtpu_flags, flow->tunnel.gtpu_msgtype, tnl_cfg->dst_port,//dev->tnl_cfg.dst_port,
+            flow->tunnel.tp_src, flow->tunnel.tp_dst,
+            IP_ARGS(flow->tunnel.ip_src), IP_ARGS(in6_addr_get_mapped_ipv4(&tnl_cfg->ipv6_dst/*&dev->tnl_cfg.ipv6_dst*/)));
+
+    if ((flow->tunnel.tp_dst == tnl_cfg->dst_port/*dev->tnl_cfg.dst_port*/) &&
+        (flow->tunnel.ip_src == in6_addr_get_mapped_ipv4(&tnl_cfg->ipv6_dst/*&dev->tnl_cfg.ipv6_dst*/))) {
+        *res = (flow->tunnel.gtpu_msgtype == 1) &&                  // echo request msg type
+               (flow->tunnel.gtpu_flags == 0x32);                   // needs seq in packet.
+
+        if (flow->tunnel.gtpu_msgtype && wc) {
+            memset(&wc->masks.tunnel.gtpu_msgtype, 0xff, sizeof wc->masks.tunnel.gtpu_msgtype);
+            memset(&wc->masks.tunnel.gtpu_flags, 0xff, sizeof wc->masks.tunnel.gtpu_flags);
+        }
+   }
+    return 0;
+}
+
+static int
+gtp_process_keep_alive_pkt(struct netdev *netdev, const struct flow *flow,
+                           const struct dp_packet *p)
+{
+    struct netdev_vport *dev = netdev_vport_cast(netdev);
+//    struct netdev_tunnel_config *cfg = &dev->tnl_cfg;
+    struct netdev_tunnel_config *cfg;
+    cfg = netdev_get_tunnel_config(netdev);
+    bool is_keep_alive;
+
+    ovs_mutex_lock(&dev->mutex);
+    gtp_is_keep_alive_pkt(netdev, flow, NULL, &is_keep_alive);
+
+    VLOG_DBG("is_keep_alive %d",(int) is_keep_alive);
+    if (is_keep_alive) {
+        struct gtp1_cntr_echo_req_header *hdr;
+
+        if (dp_packet_size(p) >= sizeof(struct gtp1_cntr_echo_req_header) &&
+            dp_packet_data(p) != NULL &&
+            flow->tunnel.gtpu_flags & GTP_FLAGS_SEQ) {
+            hdr = dp_packet_data(p);
+            cfg->gtp_seq = ntohs(hdr->seq);
+            VLOG_DBG("got seq %d", cfg->gtp_seq);
+        } else {
+            cfg->gtp_seq++;
+        }
+        cfg->gtp_timestamp = time_wall_msec();
+        cfg->gtp_need_to_send = true;
+        cfg->gtp_rx_cnt++;
+    }
+    ovs_mutex_unlock(&dev->mutex);
+
+    return 0;
+}
+
+static int
+gtp_build_keep_alive_pkt(struct netdev *netdev, struct dp_packet *p,
+                         struct ofpbuf *ofpacts, bool *more_pkts)
+{
+    struct netdev_vport *dev = netdev_vport_cast(netdev);
+    struct netdev_tunnel_config *cfg;
+    struct gtp1_cntr_echo_rsp_header *hdr;
+    ovs_be32 ip_src_flow, ip_dst_flow;
+    __u8 ttl;
+    __u8 tos;
+    __u8 gtpu_msgtype;
+    __u8 gtpu_flags;
+
+    ovs_mutex_lock(&dev->mutex);
+//    cfg = &dev->tnl_cfg;
+    cfg = netdev_get_tunnel_config(netdev);
+    if (!cfg->gtp_need_to_send) {
+        ovs_mutex_unlock(&dev->mutex);
+        return ENOENT;
+    }
+    *more_pkts = false;
+
+    ip_src_flow = in6_addr_get_mapped_ipv4(&cfg->ipv6_src);
+    ip_dst_flow = in6_addr_get_mapped_ipv4(&cfg->ipv6_dst);
+
+
+    ttl = MAXTTL;
+    tos = IPTOS_PREC_INTERNETCONTROL;
+    gtpu_msgtype = 2;
+    gtpu_flags = 0x32;
+
+    ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_SRC), &ip_src_flow, &ip_src_flow);
+    ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_DST), &ip_dst_flow, &ip_dst_flow);
+    ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_TOS), &tos, &tos);
+    ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_TTL), &ttl, &ttl);
+    ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_GTPU_FLAGS), &gtpu_flags, &gtpu_flags);
+    ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_GTPU_MSGTYPE), &gtpu_msgtype, &gtpu_msgtype);
+
+    __be16 csum = htons(FLOW_TNL_F_CSUM);
+    ofpact_put_set_field(ofpacts, mf_from_id(MFF_TUN_FLAGS), &csum, &csum);
+   
+    hdr = dp_packet_put_zeros(p, sizeof *hdr);
+    hdr->seq = htons(cfg->gtp_seq);
+    hdr->recovery.type = 14;  //htons(0x0E00); // this is added for backward compatibility only.
+    hdr->recovery.value = 0;
+    cfg->gtp_tx_cnt++;
+    cfg->gtp_need_to_send = false;
+    VLOG_DBG("gtp-echo xmit flags %x msg_type %d dev->tnl_cfg.dst_port %d src "IP_FMT" dst "IP_FMT,
+            gtpu_flags, gtpu_msgtype, cfg->dst_port/*dev->tnl_cfg.dst_port*/, IP_ARGS(ip_src_flow), IP_ARGS(ip_dst_flow));
+
+    ovs_mutex_unlock(&dev->mutex);
+    return 0;
+}
+
+static void
+netdev_gtp_echo_remote_end_points(struct unixctl_conn *conn, int argc OVS_UNUSED,
+                             const char *argv[] OVS_UNUSED, void *aux OVS_UNUSED)
+{
+    struct ds ds = DS_EMPTY_INITIALIZER;
+    struct netdev **vports;
+    size_t i, n_vports;
+
+    int rec = 0;
+
+    vports = netdev_get_vports(&n_vports);
+    for (i = 0; i < n_vports; i++) {
+        struct netdev *netdev_ = vports[i];
+        struct netdev_vport *netdev = netdev_vport_cast(netdev_);
+
+        ds_put_format(&ds, "Tunnel port: %s\n", netdev_->name);
+        ovs_mutex_lock(&netdev->mutex);
+        /* Finds all tunnel vports. */
+        gtp_get_remote_info(netdev, &ds);
+
+        ovs_mutex_unlock(&netdev->mutex);
+
+        netdev_close(netdev_);
+        rec++;
+    }
+    free(vports);
+    if (rec) {
+        unixctl_command_reply(conn, ds_cstr(&ds));
+    } else {
+        unixctl_command_reply(conn, "None");
+    }
+    ds_destroy(&ds);
+}
+
+
 static int
 netdev_vport_get_ifindex(const struct netdev *netdev_)
 {
@@ -1302,6 +1483,11 @@ netdev_vport_tunnel_register(void)
               .build_header = netdev_gtpu_build_header,
               .push_header = netdev_gtpu_push_header,
               .pop_header = netdev_gtpu_pop_header,
+              .should_send_keep_alive_pkt = gtp_should_send_keep_alive_pkt,
+              .is_keep_alive_pkt = gtp_is_keep_alive_pkt,
+              .process_keep_alive_pkt = gtp_process_keep_alive_pkt,
+              .build_keep_alive_pkt = gtp_build_keep_alive_pkt,
+              .get_ifindex = NETDEV_VPORT_GET_IFINDEX,
           },
           {{NULL, NULL, 0, 0}}
         },
@@ -1328,6 +1514,9 @@ netdev_vport_tunnel_register(void)
         unixctl_command_register("tnl/egress_port_range", "min max", 0, 2,
                                  netdev_tnl_egress_port_range, NULL);
 
+        unixctl_command_register("tnl/gtp_echo_remote_end_points", "", 0, 0,
+                                 netdev_gtp_echo_remote_end_points, NULL);
+
         ovsthread_once_done(&once);
     }
 }
diff --git a/lib/netdev.c b/lib/netdev.c
index c79778378..2b15f1ee4 100644
--- a/lib/netdev.c
+++ b/lib/netdev.c
@@ -2306,3 +2306,41 @@ netdev_free_custom_stats_counters(struct netdev_custom_stats *custom_stats)
         }
     }
 }
+
+int netdev_should_send_keep_alive_pkt(struct netdev *netdev, bool *res)
+{
+
+    if (netdev->netdev_class->should_send_keep_alive_pkt) {
+        return netdev->netdev_class->should_send_keep_alive_pkt(netdev, res);
+    }
+    return EOPNOTSUPP;
+}
+
+int
+netdev_is_keep_alive_pkt(struct netdev *netdev, const struct flow *flow,
+                              struct flow_wildcards *wc, bool *res)
+{
+    if (netdev->netdev_class->is_keep_alive_pkt) {
+        return netdev->netdev_class->is_keep_alive_pkt(netdev, flow, wc, res);
+    }
+    return EOPNOTSUPP;
+}
+
+int
+netdev_process_keep_alive_pkt(struct netdev *netdev, const struct flow *flow,
+                                  const struct dp_packet *p)
+{
+    if (netdev->netdev_class->process_keep_alive_pkt) {
+        return netdev->netdev_class->process_keep_alive_pkt(netdev, flow, p);
+    }
+    return EOPNOTSUPP;
+}
+
+int netdev_build_keep_alive_pkt(struct netdev *netdev, struct dp_packet *p,
+                                struct ofpbuf *ofpacts, bool *more_pkts)
+{
+    if (netdev->netdev_class->build_keep_alive_pkt) {
+        return netdev->netdev_class->build_keep_alive_pkt(netdev, p, ofpacts, more_pkts);
+    }
+    return EOPNOTSUPP;
+}
\ No newline at end of file
diff --git a/lib/netdev.h b/lib/netdev.h
index 47c15bde7..8e6542e02 100644
--- a/lib/netdev.h
+++ b/lib/netdev.h
@@ -129,6 +129,7 @@ struct netdev_tunnel_config {
     bool tos_inherit;
 
     bool csum;
+    bool user_setcsum;
     bool dont_fragment;
     enum netdev_pt_mode pt_mode;
 
@@ -142,6 +143,13 @@ struct netdev_tunnel_config {
     bool erspan_idx_flow;
     bool erspan_dir_flow;
     bool erspan_hwid_flow;
+
+    bool gtp_random_src_port;
+    int gtp_seq;
+    long long int gtp_timestamp;
+    bool gtp_need_to_send;
+    long gtp_rx_cnt;
+    long gtp_tx_cnt;
 };
 
 void netdev_run(void);
@@ -330,6 +338,17 @@ bool netdev_queue_dump_next(struct netdev_queue_dump *,
                             unsigned int *queue_id, struct smap *details);
 int netdev_queue_dump_done(struct netdev_queue_dump *);
 
+int netdev_should_send_keep_alive_pkt(struct netdev *, bool *res);
+
+int netdev_is_keep_alive_pkt(struct netdev *, const struct flow *flow,
+                               struct flow_wildcards *wc, bool *res);
+
+int netdev_process_keep_alive_pkt(struct netdev *, const struct flow *flow,
+                               const struct dp_packet *p);
+
+int netdev_build_keep_alive_pkt(struct netdev *, struct dp_packet *p,
+                                struct ofpbuf *ofpacts, bool *more_pkts);
+
 /* Iterates through each queue in NETDEV, using DUMP as state.  Fills QUEUE_ID
  * and DETAILS with information about queues.  The client must initialize and
  * destroy DETAILS.
diff --git a/lib/nx-match.c b/lib/nx-match.c
index 440f5f763..c8267565a 100644
--- a/lib/nx-match.c
+++ b/lib/nx-match.c
@@ -1201,7 +1201,7 @@ nx_put_raw(struct ofpbuf *b, enum ofp_version oxm, const struct match *match,
                match->wc.masks.tunnel.gtpu_flags);
     nxm_put_8m(&ctx, MFF_TUN_GTPU_MSGTYPE, oxm, flow->tunnel.gtpu_msgtype,
                match->wc.masks.tunnel.gtpu_msgtype);
-
+    nxm_put_8m(&ctx, MFF_QFI, oxm, flow->tunnel.qfi, match->wc.masks.tunnel.qfi);
     /* Network Service Header */
     nxm_put_8m(&ctx, MFF_NSH_FLAGS, oxm, flow->nsh.flags,
             match->wc.masks.nsh.flags);
diff --git a/lib/odp-util.c b/lib/odp-util.c
index fac4cf3a8..db0a6abb9 100644
--- a/lib/odp-util.c
+++ b/lib/odp-util.c
@@ -2456,6 +2456,11 @@ parse_odp_action__(struct parse_odp_context *context, const char *s,
         return 8;
     }
 
+    if (!strncmp(s, "pop_eth", 7)) {
+        nl_msg_put_flag(actions, OVS_ACTION_ATTR_POP_ETH);
+        return 7;
+    }
+
     {
         unsigned long long int meter_id;
         int n = -1;
@@ -3117,8 +3122,16 @@ odp_tun_key_from_attr__(const struct nlattr *attr, bool is_mask,
         case OVS_TUNNEL_KEY_ATTR_GTPU_OPTS: {
             const struct gtpu_metadata *opts = nl_attr_get(a);
 
-            tun->gtpu_flags = opts->flags;
-            tun->gtpu_msgtype = opts->msgtype;
+            if (opts->ver == GTP_METADATA_V1) {
+                tun->gtpu_flags = opts->flags;
+                tun->gtpu_msgtype = opts->msgtype;
+                if (opts->qfi) {
+                    tun->qfi = opts->qfi;
+                }
+            } else {
+                VLOG_WARN("%s invalid gtp opts version : %d\n", __func__, opts->ver);
+            }
+
             break;
         }
 
@@ -3236,11 +3249,15 @@ tun_key_to_attr(struct ofpbuf *a, const struct flow_tnl *tun_key,
     }
 
     if ((!tnl_type || !strcmp(tnl_type, "gtpu")) &&
-        (tun_key->gtpu_flags && tun_key->gtpu_msgtype)) {
+        ((tun_key->gtpu_flags && tun_key->gtpu_msgtype) || tun_key->qfi)) {
         struct gtpu_metadata opts;
 
         opts.flags = tun_key->gtpu_flags;
         opts.msgtype = tun_key->gtpu_msgtype;
+        opts.ver = GTP_METADATA_V1;
+        if (tun_key->qfi) {
+            opts.qfi = tun_key->qfi;
+        }
         nl_msg_put_unspec(a, OVS_TUNNEL_KEY_ATTR_GTPU_OPTS,
                           &opts, sizeof(opts));
     }
@@ -3502,8 +3519,8 @@ format_ipv6_label(struct ds *ds, const char *name, ovs_be32 key,
 }
 
 static void
-format_u8x(struct ds *ds, const char *name, uint8_t key,
-           const uint8_t *mask, bool verbose)
+format_u8x___(struct ds *ds, const char *name, uint8_t key,
+           const uint8_t *mask, bool verbose, bool add_comma)
 {
     bool mask_empty = mask && !*mask;
 
@@ -3514,10 +3531,19 @@ format_u8x(struct ds *ds, const char *name, uint8_t key,
         if (!mask_full) { /* Partially masked. */
             ds_put_format(ds, "/%#"PRIx8, *mask);
         }
-        ds_put_char(ds, ',');
+        if (add_comma) {
+            ds_put_char(ds, ',');
+        }
     }
 }
 
+static void
+format_u8x(struct ds *ds, const char *name, uint8_t key,
+           const uint8_t *mask, bool verbose)
+{
+    format_u8x___(ds, name, key, mask, verbose, true);
+}
+
 static void
 format_u8u(struct ds *ds, const char *name, uint8_t key,
            const uint8_t *mask, bool verbose)
@@ -3753,14 +3779,29 @@ format_odp_tun_gtpu_opt(const struct nlattr *attr,
                         bool verbose)
 {
     const struct gtpu_metadata *opts, *mask;
+    uint8_t ver, ver_ma;
 
     opts = nl_attr_get(attr);
     mask = mask_attr ? nl_attr_get(mask_attr) : NULL;
 
-    format_u8x(ds, "flags", opts->flags, mask ? &mask->flags : NULL, verbose);
-    format_u8u(ds, "msgtype", opts->msgtype, mask ? &mask->msgtype : NULL,
-               verbose);
-    ds_chomp(ds, ',');
+    ver = (uint8_t)opts->ver;
+    if (mask) {
+        ver_ma = (uint8_t)mask->ver;
+    }
+
+    format_u8u(ds, "ver", ver, mask ? &ver_ma : NULL, verbose);
+
+    if (opts->ver == GTP_METADATA_V1) {
+        format_u8x(ds, "flags", opts->flags, !!mask ? &mask->flags : NULL, verbose);
+        format_u8x(ds, "msgtype", opts->msgtype, !!mask ? &mask->msgtype : NULL, verbose);
+        if (opts->qfi) {
+            format_u8x(ds, "qfi", opts->qfi, !!mask ? &mask->qfi : NULL, verbose);
+        }
+        ds_chomp(ds, ',');
+    }else {
+        ds_put_format(ds, "Unknown opt ver %d", opts->ver);
+    }
+
 }
 
 #define MASK(PTR, FIELD) PTR ? &PTR->FIELD : NULL
@@ -5238,9 +5279,22 @@ scan_gtpu_metadata(const char *s,
                    struct gtpu_metadata *mask)
 {
     const char *s_base = s;
+    uint8_t ver = 0, ver_ma = 0;
     uint8_t flags = 0, flags_ma = 0;
     uint8_t msgtype = 0, msgtype_ma = 0;
     int len;
+    if (!strncmp(s, "ver=", 4)) {
+        s += 4;
+        len = scan_u8(s, &ver, mask ? &ver_ma : NULL);
+        if (len == 0) {
+            return 0;
+        }
+        s += len;
+    }
+    if (s[0] == ',') {
+        s++;
+    }
+
 
     if (!strncmp(s, "flags=", 6)) {
         s += 6;
@@ -5266,9 +5320,11 @@ scan_gtpu_metadata(const char *s,
 
     if (!strncmp(s, ")", 1)) {
         s += 1;
+        key->ver = ver;
         key->flags = flags;
         key->msgtype = msgtype;
         if (mask) {
+            mask->ver = ver_ma;
             mask->flags = flags_ma;
             mask->msgtype = msgtype_ma;
         }
@@ -8651,6 +8707,27 @@ odp_put_push_nsh_action(struct ofpbuf *odp_actions,
     nl_msg_end_nested(odp_actions, offset);
 }
 
+static void OVS_PRINTF_FORMAT(2, 3)
+log_flow(const struct flow *flow, const char *format, ...)
+{
+    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);
+    if (VLOG_DROP_DBG(&rl)) {
+        return;
+    }
+
+    struct ds s = DS_EMPTY_INITIALIZER;
+    va_list args;
+    va_start(args, format);
+    ds_put_format_valist(&s, format, args);
+    va_end(args);
+
+    ds_put_cstr(&s, " Unexpected state while processing ");
+    flow_format(&s, flow, NULL);
+    VLOG_DBG("%s", ds_cstr(&s));
+    ds_destroy(&s);
+}
+
+
 static void
 commit_encap_decap_action(const struct flow *flow,
                           struct flow *base_flow,
@@ -8686,7 +8763,8 @@ commit_encap_decap_action(const struct flow *flow,
         default:
             /* Only the above protocols are supported for encap.
              * The check is done at action translation. */
-            OVS_NOT_REACHED();
+            log_flow(flow, "pending encap");
+            return;
         }
     } else if (pending_decap || flow->packet_type != base_flow->packet_type) {
         /* This is an explicit or implicit decap case. */
@@ -8712,7 +8790,8 @@ commit_encap_decap_action(const struct flow *flow,
                 break;
             default:
                 /* Checks are done during translation. */
-                OVS_NOT_REACHED();
+                log_flow(flow, "pending dencap");
+                return;
             }
         }
     }
diff --git a/lib/odp-util.h b/lib/odp-util.h
index a1d0d0fba..a32ab220b 100644
--- a/lib/odp-util.h
+++ b/lib/odp-util.h
@@ -335,6 +335,12 @@ struct user_action_cookie {
             uint32_t obs_point_id;  /* Observation Point ID. */
             odp_port_t output_odp_port; /* The output odp port. */
             enum nx_action_sample_direction direction;
+            ovs_be64 flow_metadata;
+            uint32_t app_name;
+            uint8_t msisdn[16];
+            struct eth_addr apn_mac_addr;
+            uint8_t apn_name[24];
+            uint64_t pdp_start_epoch;
         } flow_sample;
 
         struct {
@@ -354,7 +360,7 @@ struct user_action_cookie {
         } controller;
     };
 };
-BUILD_ASSERT_DECL(sizeof(struct user_action_cookie) == 48);
+BUILD_ASSERT_DECL(sizeof(struct user_action_cookie) == 120);
 
 int odp_put_userspace_action(uint32_t pid,
                              const void *userdata, size_t userdata_size,
diff --git a/lib/ofp-actions.c b/lib/ofp-actions.c
index c13f97b5c..1101e17e7 100644
--- a/lib/ofp-actions.c
+++ b/lib/ofp-actions.c
@@ -363,6 +363,8 @@ enum ofp_raw_action_type {
 
     /* NX1.0+(50): struct nx_action_delete_field. VLMFF */
     NXAST_RAW_DELETE_FIELD,
+    /* NX1.0+(51): uint8_t. */
+    NXAST_RAW_SET_TUNNEL_QFI,
 
 /* ## ------------------ ## */
 /* ## Debugging actions. ## */
@@ -504,6 +506,7 @@ ofpact_next_flattened(const struct ofpact *ofpact)
     case OFPACT_DEC_NSH_TTL:
     case OFPACT_CHECK_PKT_LARGER:
     case OFPACT_DELETE_FIELD:
+    case OFPACT_SET_TUNNEL_QFI:
         return ofpact_next(ofpact);
 
     case OFPACT_CLONE:
@@ -2504,6 +2507,7 @@ OFP_ASSERT(sizeof(struct onf_action_copy_field) == 24);
  *   - NXM_NX_PKT_MARK
  *   - NXM_NX_TUN_IPV4_SRC
  *   - NXM_NX_TUN_IPV4_DST
+ *   - NXM_NX_QFI
  *
  * The following nxm_header values are potentially acceptable as 'dst':
  *
@@ -4177,6 +4181,70 @@ check_SET_TUNNEL(const struct ofpact_tunnel *a OVS_UNUSED,
 {
     return 0;
 }
+
+static void
+encode_SET_TUNNEL_QFI(const struct ofpact_tun_qfi *tun_qfi,
+                  enum ofp_version ofp_version, struct ofpbuf *out)
+{
+    uint8_t qfi = tun_qfi->qfi;
+    VLOG_DBG(" tun qfi:%d\n", qfi);
+    if (ofp_version < OFP12_VERSION) {
+        put_NXAST_SET_TUNNEL_QFI(out, qfi);
+    } else {
+        put_set_field(out, ofp_version, MFF_QFI, qfi);
+    }
+}
+
+static enum ofperr
+decode_NXAST_RAW_SET_TUNNEL_QFI(uint8_t qfi,
+                            enum ofp_version ofp_version OVS_UNUSED,
+                            struct ofpbuf *out)
+{
+    struct ofpact_tun_qfi *tunnel_qfi = ofpact_put_SET_TUNNEL_QFI(out);
+    tunnel_qfi->ofpact.raw = NXAST_RAW_SET_TUNNEL_QFI;
+    tunnel_qfi->qfi = qfi;
+    VLOG_DBG(" RAW tun qfi:%d\n", qfi);
+    return 0;
+}
+
+static char * OVS_WARN_UNUSED_RESULT
+parse_set_tunnel_qfi(char *arg, const struct ofpact_parse_params *pp)
+{
+    char *error;
+    uint8_t qfi;
+    struct ofpact_tun_qfi *tunnel_qfi;
+
+    error = str_to_u8(arg, "qfi", &qfi);
+    if (error) {
+        return error;
+    }
+    tunnel_qfi = ofpact_put_SET_TUNNEL_QFI(pp->ofpacts);
+    tunnel_qfi->ofpact.raw = NXAST_RAW_SET_TUNNEL_QFI;
+    tunnel_qfi->qfi = qfi;
+    return NULL;
+}
+
+static char * OVS_WARN_UNUSED_RESULT
+parse_SET_TUNNEL_QFI(char *arg, const struct ofpact_parse_params *pp)
+{
+    return parse_set_tunnel_qfi(arg, pp);
+}
+
+static void
+format_SET_TUNNEL_QFI(const struct ofpact_tun_qfi *a,
+                  const struct ofpact_format_params *fp)
+{
+    ds_put_format(fp->s, "%sqfi:%s%d", colors.param,
+                  colors.end, a->qfi);
+}
+
+static enum ofperr
+check_SET_TUNNEL_QFI(const struct ofpact_tun_qfi *a OVS_UNUSED,
+                 const struct ofpact_check_params *cp OVS_UNUSED)
+{
+    return 0;
+}
+
 
 /* Delete field action. */
 
@@ -6173,10 +6241,14 @@ struct nx_action_sample2 {
     ovs_be32 obs_domain_id;         /* ID of sampling observation domain. */
     ovs_be32 obs_point_id;          /* ID of sampling observation point. */
     ovs_be16 sampling_port;         /* Sampling port. */
+    uint8_t  msisdn[16];
+    struct   eth_addr apn_mac_addr;
+    uint8_t  apn_name[24];
+    uint64_t pdp_start_epoch;
     uint8_t  direction;             /* NXAST_SAMPLE3 only. */
     uint8_t  zeros[5];              /* Pad to a multiple of 8 bytes */
  };
- OFP_ASSERT(sizeof(struct nx_action_sample2) == 32);
+ OFP_ASSERT(sizeof(struct nx_action_sample2) == 88);
 
 static enum ofperr
 decode_NXAST_RAW_SAMPLE(const struct nx_action_sample *nas,
@@ -6213,6 +6285,10 @@ decode_SAMPLE2(const struct nx_action_sample2 *nas,
     sample->obs_domain_id = ntohl(nas->obs_domain_id);
     sample->obs_point_id = ntohl(nas->obs_point_id);
     sample->sampling_port = u16_to_ofp(ntohs(nas->sampling_port));
+    sample->apn_mac_addr = nas->apn_mac_addr;
+    sample->pdp_start_epoch = nas->pdp_start_epoch;
+    memcpy(&sample->msisdn, &nas->msisdn, 16);
+    memcpy(&sample->apn_name, &nas->apn_name, 24);
     sample->direction = direction;
 
     if (sample->probability == 0) {
@@ -6259,6 +6335,10 @@ encode_SAMPLE2(const struct ofpact_sample *sample,
     nas->obs_point_id = htonl(sample->obs_point_id);
     nas->sampling_port = htons(ofp_to_u16(sample->sampling_port));
     nas->direction = sample->direction;
+    memcpy(&nas->msisdn, &sample->msisdn, 16);
+    nas->apn_mac_addr = sample->apn_mac_addr;
+    memcpy(&nas->apn_name, &sample->apn_name, 24);
+    nas->pdp_start_epoch = sample->pdp_start_epoch;
 }
 
 static void
@@ -6291,8 +6371,11 @@ parse_SAMPLE(char *arg, const struct ofpact_parse_params *pp)
     struct ofpact_sample *os = ofpact_put_SAMPLE(pp->ofpacts);
     os->sampling_port = OFPP_NONE;
     os->direction = NX_ACTION_SAMPLE_DEFAULT;
+    memset(&os->msisdn, 0, 16);
+    memset(&os->apn_name, 0, 24);
 
     char *key, *value;
+    int i;
     while (ofputil_parse_key_value(&arg, &key, &value)) {
         char *error = NULL;
 
@@ -6301,6 +6384,25 @@ parse_SAMPLE(char *arg, const struct ofpact_parse_params *pp)
             if (!error && os->probability == 0) {
                 error = xasprintf("invalid probability value \"%s\"", value);
             }
+        } else if (!strcmp(key, "apn_name")) {
+            int j = 0;
+            for (i = 0; i < 24; i++) {
+                if (value[i] == '"')
+                    continue;
+                os->apn_name[j++] = (uint8_t)value[i];
+                if ((char)value[i] == '\0')
+                    break;
+            }
+        } else if (!strcmp(key, "msisdn")) {
+            for (i = 0; i < 16; i++) {
+                os->msisdn[i] = (uint8_t)value[i];
+                if ((char)value[i] == '\0')
+                    break;
+            }
+        } else if (!strcmp(key, "apn_mac_addr")) {
+            error = str_to_mac(value, &os->apn_mac_addr);
+        } else if (!strcmp(key, "pdp_start_epoch")) {
+            error = str_to_u64(value, &os->pdp_start_epoch);
         } else if (!strcmp(key, "collector_set_id")) {
             error = str_to_u32(value, &os->collector_set_id);
         } else if (!strcmp(key, "obs_domain_id")) {
@@ -6338,12 +6440,27 @@ format_SAMPLE(const struct ofpact_sample *a,
     ds_put_format(fp->s, "%ssample(%s%sprobability=%s%"PRIu16
                   ",%scollector_set_id=%s%"PRIu32
                   ",%sobs_domain_id=%s%"PRIu32
-                  ",%sobs_point_id=%s%"PRIu32,
+                  ",%sobs_point_id=%s%"PRIu32
+                  ",%spdp_start_epoch=%s%"PRIu64,
                   colors.paren, colors.end,
                   colors.param, colors.end, a->probability,
                   colors.param, colors.end, a->collector_set_id,
                   colors.param, colors.end, a->obs_domain_id,
-                  colors.param, colors.end, a->obs_point_id);
+                  colors.param, colors.end, a->obs_point_id,
+                  colors.param, colors.end, a->pdp_start_epoch);
+    if (!eth_addr_is_zero(a->apn_mac_addr)) {
+        ds_put_format(fp->s,  ",%sapn_mac_addr=%s"ETH_ADDR_FMT,
+                  colors.param, colors.end, ETH_ADDR_ARGS(a->apn_mac_addr));
+
+    }
+    if (strlen((const char *)a->msisdn)) {
+        ds_put_format(fp->s, ",%smsisdn=%s%s", colors.param, colors.end, a->msisdn);
+    }
+    if (strlen((const char *)a->apn_name)) {
+        char buf[32], *name;
+        name = str_quotify((char *)a->apn_name, 24, buf);
+        ds_put_format(fp->s, ",%sapn_name=%s%s", colors.param, colors.end, name);
+    }
     if (a->sampling_port != OFPP_NONE) {
         ds_put_format(fp->s, ",%ssampling_port=%s", colors.param, colors.end);
         ofputil_format_port(a->sampling_port, fp->port_map, fp->s);
@@ -7973,6 +8090,7 @@ action_set_classify(const struct ofpact *a)
     case OFPACT_SET_TUNNEL:
     case OFPACT_SET_VLAN_PCP:
     case OFPACT_SET_VLAN_VID:
+    case OFPACT_SET_TUNNEL_QFI:
         return ACTION_SLOT_SET_OR_MOVE;
 
     case OFPACT_BUNDLE:
@@ -8206,6 +8324,7 @@ ovs_instruction_type_from_ofpact_type(enum ofpact_type type,
     case OFPACT_DEC_NSH_TTL:
     case OFPACT_CHECK_PKT_LARGER:
     case OFPACT_DELETE_FIELD:
+    case OFPACT_SET_TUNNEL_QFI:
     default:
         return OVSINST_OFPIT11_APPLY_ACTIONS;
     }
@@ -9118,6 +9237,7 @@ ofpact_outputs_to_port(const struct ofpact *ofpact, ofp_port_t port)
     case OFPACT_DEC_NSH_TTL:
     case OFPACT_CHECK_PKT_LARGER:
     case OFPACT_DELETE_FIELD:
+    case OFPACT_SET_TUNNEL_QFI:
     default:
         return false;
     }
@@ -9372,6 +9492,8 @@ ofpacts_parse__(char *str, const struct ofpact_parse_params *pp,
             error = parse_pop_vlan(pp);
         } else if (!strcasecmp(key, "set_tunnel64")) {
             error = parse_set_tunnel(value, NXAST_RAW_SET_TUNNEL64, pp);
+        } else if (!strcasecmp(key, "qfi")) {
+            error = parse_set_tunnel_qfi(value, pp);
         } else if (!strcasecmp(key, "load")) {
             error = parse_reg_load(value, pp);
         } else if (!strcasecmp(key, "bundle_load")) {
diff --git a/lib/ofp-parse.c b/lib/ofp-parse.c
index 102b183a8..8bafe4529 100644
--- a/lib/ofp-parse.c
+++ b/lib/ofp-parse.c
@@ -316,9 +316,16 @@ ofputil_parse_key_value(char **stringp, char **keyp, char **valuep)
      *     - If key_delim is "(", the value extends until ")".
      *
      * If there is no value, we are done. */
+    char *value = *stringp;
     const char *value_delims;
+    bool value_with_quote = false;
     if (key_delim == ':' || key_delim == '=') {
-        value_delims = ", \t\r\n";
+        if (*value == '\"') {
+            value_delims = "\"";
+            value_with_quote = true;
+        } else {
+            value_delims = ", \t\r\n";
+        }
     } else if (key_delim == '(') {
         value_delims = ")";
     } else {
@@ -329,8 +336,12 @@ ofputil_parse_key_value(char **stringp, char **keyp, char **valuep)
 
     /* Extract the value.  Advance the input position past the value and
      * delimiter. */
-    char *value = *stringp;
-    size_t value_len = parse_value(value, value_delims);
+    size_t value_len;
+    if (value_with_quote) {
+        value_len = parse_value(value + 1, value_delims);
+    } else {
+        value_len = parse_value(value, value_delims);
+    }
     char value_delim = value[value_len];
 
     /* Handle the special case if the value is of the form "(x)->y".
@@ -342,7 +353,11 @@ ofputil_parse_key_value(char **stringp, char **keyp, char **valuep)
         value_len += parse_value(&value[value_len], value_delims);
         value_delim = value[value_len];
     }
+    if (value_with_quote) {
+        value_len += 2;
+    }
     value[value_len] = '\0';
+
     *stringp += value_len + (value_delim != '\0');
 
     *keyp = key;
diff --git a/lib/ovs-router.c b/lib/ovs-router.c
index 5d0fbd503..e53799c26 100644
--- a/lib/ovs-router.c
+++ b/lib/ovs-router.c
@@ -160,8 +160,10 @@ static void rt_init_match(struct match *match, uint32_t mark,
     memset(match, 0, sizeof *match);
     match->flow.ipv6_dst = dst;
     match->wc.masks.ipv6_dst = mask;
-    match->wc.masks.pkt_mark = UINT32_MAX;
-    match->flow.pkt_mark = mark;
+    if (mark) {
+        match->wc.masks.pkt_mark = UINT32_MAX;
+        match->flow.pkt_mark = mark;
+    }
 }
 
 int
diff --git a/lib/packets.h b/lib/packets.h
index 5bdf6e4bb..73a17bbd3 100644
--- a/lib/packets.h
+++ b/lib/packets.h
@@ -1434,18 +1434,35 @@ static inline ovs_be32 get_erspan_ts(enum erspan_ts_gra gra)
 #define GTPU_MSGTYPE_REPL   2   /* Echo Reply. */
 #define GTPU_MSGTYPE_GPDU   255 /* User Payload. */
 
+enum {
+    GTP_METADATA_V1
+};
+
+#define GTP_FLAGS_SEQ   0x02
+
 struct gtpu_metadata {
+    uint8_t ver;
     uint8_t flags;
     uint8_t msgtype;
+    uint8_t qfi;
 };
-BUILD_ASSERT_DECL(sizeof(struct gtpu_metadata) == 2);
+BUILD_ASSERT_DECL(sizeof(struct gtpu_metadata) == 4);
 
+/*
+ * GTP flags:
+ * 001-  ----    Version: GTP release 99: ver (1)
+ * ---1  ----    Protocol type: GTP(1)
+ * ----  0---    Reserved.
+ * ----  -1--    Extension header present.
+ * ----  --1-    Seq number is present.
+ * ----  ---1    Is N-PDU number present.
+ */
 struct gtpuhdr {
     struct gtpu_metadata md;
     ovs_be16 len;
     ovs_16aligned_be32 teid;
 };
-BUILD_ASSERT_DECL(sizeof(struct gtpuhdr) == 8);
+BUILD_ASSERT_DECL(sizeof(struct gtpuhdr) == 10);
 
 struct gtpuhdr_opt {
     ovs_be16 seqno;
@@ -1454,6 +1471,14 @@ struct gtpuhdr_opt {
 };
 BUILD_ASSERT_DECL(sizeof(struct gtpuhdr_opt) == 4);
 
+struct gtpu_ext_hdr {
+    uint8_t len;
+    uint8_t pdu_type;
+    uint8_t qfi;
+    uint8_t next_type;
+};
+BUILD_ASSERT_DECL(sizeof(struct gtpu_ext_hdr) == 4);
+
 /* VXLAN protocol header */
 struct vxlanhdr {
     union {
diff --git a/lib/string.c b/lib/string.c
index e7e265bdf..ea81f906b 100644
--- a/lib/string.c
+++ b/lib/string.c
@@ -44,3 +44,27 @@ char *strcasestr(const char *str, const char *substr)
     return NULL;
 }
 #endif
+
+/* Expect string 'd' is atleast three char longer than 's'. */
+char *
+str_quotify(const char *s, int len, char *d)
+{
+    bool found_space = false;
+    int i = 0;
+
+    d[0] = '"';
+    while(s[i] != '\0' && i <= len) {
+        d[i + 1] = s[i];
+        if (s[i] == ' ') {
+            found_space = true;
+        }
+        i++;
+    }
+    if (found_space) {
+        d[i + 1] = '"';
+        d[i + 2] = '\0';
+        return d;
+    } else {
+        return &d[1];
+    }
+}
\ No newline at end of file
diff --git a/lib/string.h.in b/lib/string.h.in
index 7a8e18f41..69565c9a9 100644
--- a/lib/string.h.in
+++ b/lib/string.h.in
@@ -45,4 +45,5 @@ char *strcasestr(const char *, const char *);
 size_t strnlen(const char *, size_t maxlen);
 #endif
 
+char *str_quotify(const char *s, int len, char *d);
 #endif /* string.h wrapper */
diff --git a/ofproto/ipfix-enterprise-entities.def b/ofproto/ipfix-enterprise-entities.def
index 73a520c25..f59b69115 100644
--- a/ofproto/ipfix-enterprise-entities.def
+++ b/ofproto/ipfix-enterprise-entities.def
@@ -14,4 +14,12 @@ IPFIX_ENTERPRISE_ENTITY(TUNNEL_SOURCE_TRANSPORT_PORT, 896, 2, tunnelSourceTransp
 IPFIX_ENTERPRISE_ENTITY(TUNNEL_DESTINATION_TRANSPORT_PORT, 897, 2, tunnelDestinationTransportPort, IPFIX_ENTERPRISE_VMWARE)
 IPFIX_ENTERPRISE_ENTITY(VIRTUAL_OBS_ID, 898, 0, virtualObsID, IPFIX_ENTERPRISE_VMWARE)
 
+#define IPFIX_ENTERPRISE_IPDR 6888
+IPFIX_ENTERPRISE_ENTITY(IMSI_REG, 899, 8, imsiRegister, IPFIX_ENTERPRISE_IPDR)
+IPFIX_ENTERPRISE_ENTITY(MSISDN, 900, 16, msisdn, IPFIX_ENTERPRISE_IPDR)
+IPFIX_ENTERPRISE_ENTITY(APN_MAC_ADDRESS, 901, 6, apnMacAddress, IPFIX_ENTERPRISE_IPDR)
+IPFIX_ENTERPRISE_ENTITY(APN_NAME, 902, 24, apnName, IPFIX_ENTERPRISE_IPDR)
+IPFIX_ENTERPRISE_ENTITY(APP_NAME, 903, 4, appName, IPFIX_ENTERPRISE_IPDR)
+IPFIX_ENTERPRISE_ENTITY(PDP_START_EPOCH, 904, 8, pdpStartEpoch, IPFIX_ENTERPRISE_IPDR)
+
 #undef IPFIX_ENTERPRISE_ENTITY
diff --git a/ofproto/ofproto-dpif-ipfix.c b/ofproto/ofproto-dpif-ipfix.c
index f13478a88..3c259214b 100644
--- a/ofproto/ofproto-dpif-ipfix.c
+++ b/ofproto/ofproto-dpif-ipfix.c
@@ -88,6 +88,7 @@ enum dpif_ipfix_tunnel_type {
     DPIF_IPFIX_TUNNEL_LISP = 0x03,
     DPIF_IPFIX_TUNNEL_STT = 0x04,
     DPIF_IPFIX_TUNNEL_GENEVE = 0x07,
+    DPIF_IPFIX_TUNNEL_GTP = 0x08,
     NUM_DPIF_IPFIX_TUNNEL
 };
 
@@ -396,6 +397,7 @@ static uint8_t tunnel_protocol[NUM_DPIF_IPFIX_TUNNEL] = {
     IPPROTO_TCP,    /* DPIF_IPFIX_TUNNEL_STT*/
     0          ,    /* reserved */
     IPPROTO_UDP,    /* DPIF_IPFIX_TUNNEL_GENEVE*/
+    IPPROTO_UDP,    /* DPIF_IPFIX_TUNNEL_GTP*/
 };
 
 OVS_PACKED(
@@ -411,6 +413,17 @@ struct ipfix_data_record_flow_key_tunnel {
 });
 BUILD_ASSERT_DECL(sizeof(struct ipfix_data_record_flow_key_tunnel) == 15);
 
+OVS_PACKED(
+struct ipfix_data_ipdr_fields {
+    ovs_be64 imsi;  /* IMSI_REGISTER*/
+    uint8_t msisdn[16];  /* MSISDN */
+    struct eth_addr apn_mac_address;  /* APN_MAC_ADDRESS */
+    uint8_t apn_name[24];  /* APN_NAME */
+    uint32_t app_name;  /* APP_NAME */
+    uint64_t pdp_start_epoch; /* PDP_START_EPOCH */
+});
+BUILD_ASSERT_DECL(sizeof(struct ipfix_data_ipdr_fields) == 66);
+
 /* Cf. IETF RFC 5102 Section 5.11.3. */
 enum ipfix_flow_end_reason {
     IDLE_TIMEOUT = 0x01,
@@ -516,6 +529,7 @@ BUILD_ASSERT_DECL(sizeof(struct ipfix_data_record_aggregated_tcp) == 48);
  * support tunnel key for:
  * VxLAN: 24-bit VIN,
  * GRE: 32-bit key,
+ * GTP: 32-bit key,
  * LISP: 24-bit instance ID
  * STT: 64-bit key
  */
@@ -543,6 +557,7 @@ BUILD_ASSERT_DECL(sizeof(struct ipfix_data_record_aggregated_tcp) == 48);
      + MAX(sizeof(struct ipfix_data_record_flow_key_icmp),      \
            sizeof(struct ipfix_data_record_flow_key_transport)) \
      + sizeof(struct ipfix_data_record_flow_key_tunnel)         \
+     + sizeof(struct ipfix_data_ipdr_fields)                    \
      + MAX_TUNNEL_KEY_LEN)
 
 #define MAX_DATA_RECORD_LEN                                 \
@@ -857,6 +872,8 @@ dpif_ipfix_tunnel_type(const struct ofport *ofport)
         return DPIF_IPFIX_TUNNEL_VXLAN;
     } else if (strcmp(type, "lisp") == 0) {
         return DPIF_IPFIX_TUNNEL_LISP;
+    } else if (strcmp(type, "gtpu") == 0) {
+        return DPIF_IPFIX_TUNNEL_GTP;
     } else if (strcmp(type, "geneve") == 0) {
         return DPIF_IPFIX_TUNNEL_GENEVE;
     } else if (strcmp(type, "stt") == 0) {
@@ -872,6 +889,7 @@ dpif_ipfix_tunnel_key_length(enum dpif_ipfix_tunnel_type tunnel_type)
 
     switch (tunnel_type) {
         case DPIF_IPFIX_TUNNEL_GRE:
+        case DPIF_IPFIX_TUNNEL_GTP:
             /* 32-bit key gre */
             return 4;
         case DPIF_IPFIX_TUNNEL_VXLAN:
@@ -1549,6 +1567,14 @@ ipfix_define_template_fields(enum ipfix_proto_l2 l2, enum ipfix_proto_l3 l3,
         DEF(TUNNEL_KEY);
     }
 
+    /* Custom IPDR fields */
+    DEF(IMSI_REG);
+    DEF(MSISDN);
+    DEF(APN_MAC_ADDRESS);
+    DEF(APN_NAME);
+    DEF(APP_NAME);
+    DEF(PDP_START_EPOCH);
+
     /* 2. Virtual observation ID, which is not a part of flow key. */
     if (virtual_obs_id_set) {
         DEF(VIRTUAL_OBS_ID);
@@ -2165,6 +2191,9 @@ ipfix_cache_entry_init(const struct dpif_ipfix *di,
                        uint64_t packet_delta_count, uint32_t obs_domain_id,
                        uint32_t obs_point_id, odp_port_t output_odp_port,
                        enum nx_action_sample_direction direction,
+                       ovs_be64 flow_metadata, uint8_t *msisdn,
+                       struct eth_addr *apn_mac_addr, uint8_t *apn_name,
+                       uint32_t app_name, uint64_t pdp_start_epoch,
                        const struct dpif_ipfix_port *tunnel_port,
                        const struct flow_tnl *tunnel_key,
                        struct dpif_ipfix_global_stats *stats,
@@ -2361,6 +2390,20 @@ ipfix_cache_entry_init(const struct dpif_ipfix *di,
                tunnel_port->tunnel_key_length);
     }
 
+    /* Add custom IPDR fields */
+    struct ipfix_data_ipdr_fields *ipdr_data;
+
+    ipdr_data = dp_packet_put_zeros(&msg, sizeof *ipdr_data);
+    ipdr_data->imsi = flow_metadata;
+    ipdr_data->app_name = app_name;
+    ipdr_data->pdp_start_epoch = pdp_start_epoch;
+    if (msisdn != NULL)
+        memcpy(&ipdr_data->msisdn, msisdn, 16);
+    if (apn_mac_addr != NULL)
+        memcpy(&ipdr_data->apn_mac_address, apn_mac_addr, sizeof(struct eth_addr));
+    if (apn_name != NULL)
+        memcpy(&ipdr_data->apn_name, apn_name, 24);
+
     flow_key->flow_key_msg_part_size = dp_packet_size(&msg);
 
     if (eth_addr_is_broadcast(flow->dl_dst)) {
@@ -2734,6 +2777,9 @@ dpif_ipfix_sample(const struct dpif_ipfix *di,
                   uint64_t packet_delta_count, uint32_t obs_domain_id,
                   uint32_t obs_point_id, odp_port_t output_odp_port,
                   enum nx_action_sample_direction direction,
+                  ovs_be64 flow_metadata, uint8_t *msisdn,
+                  struct eth_addr *apn_mac_addr, uint8_t *apn_name,
+                  uint32_t app_name, uint64_t pdp_start_epoch,
                   const struct dpif_ipfix_port *tunnel_port,
                   const struct flow_tnl *tunnel_key,
                   const struct dpif_ipfix_actions *ipfix_actions)
@@ -2749,6 +2795,9 @@ dpif_ipfix_sample(const struct dpif_ipfix *di,
                                    flow, packet_delta_count,
                                    obs_domain_id, obs_point_id,
                                    output_odp_port, direction,
+                                   flow_metadata, msisdn,
+                                   apn_mac_addr, apn_name,
+                                   app_name, pdp_start_epoch,
                                    tunnel_port, tunnel_key,
                                    &exporter->ipfix_global_stats,
                                    ipfix_actions);
@@ -2817,6 +2866,7 @@ dpif_ipfix_bridge_sample(struct dpif_ipfix *di, const struct dp_packet *packet,
                       di->bridge_exporter.options->obs_domain_id,
                       di->bridge_exporter.options->obs_point_id,
                       output_odp_port, NX_ACTION_SAMPLE_DEFAULT,
+                      0, NULL, NULL, NULL, 0, 0, //not available for bridge export
                       tunnel_port, tunnel_key, ipfix_actions);
     ovs_mutex_unlock(&mutex);
 }
@@ -2862,6 +2912,9 @@ dpif_ipfix_flow_sample(struct dpif_ipfix *di, const struct dp_packet *packet,
                           cookie->flow_sample.obs_domain_id,
                           cookie->flow_sample.obs_point_id,
                           output_odp_port, cookie->flow_sample.direction,
+                          cookie->flow_sample.flow_metadata, (uint8_t *)&cookie->flow_sample.msisdn,
+                          (struct eth_addr *)&cookie->flow_sample.apn_mac_addr, (uint8_t *)&cookie->flow_sample.apn_name,
+                          cookie->flow_sample.app_name, cookie->flow_sample.pdp_start_epoch,
                           tunnel_port, tunnel_key, ipfix_actions);
     }
     ovs_mutex_unlock(&mutex);
diff --git a/ofproto/ofproto-dpif-monitor.c b/ofproto/ofproto-dpif-monitor.c
index bb0e49091..42bf211e9 100644
--- a/ofproto/ofproto-dpif-monitor.c
+++ b/ofproto/ofproto-dpif-monitor.c
@@ -280,11 +280,17 @@ monitor_mport_run(struct mport *mport, struct dp_packet *packet)
         ofproto_dpif_send_packet(mport->ofport, false, packet);
     }
     if (mport->bfd && bfd_should_send_packet(mport->bfd)) {
-        bool oam;
+        uint64_t ofpacts_stub[4192 / 8];
+        struct ofpbuf ofpacts;
+        int err;
+
+        ofpbuf_use_stack(&ofpacts, ofpacts_stub, sizeof ofpacts_stub);
 
         dp_packet_clear(packet);
-        bfd_put_packet(mport->bfd, packet, mport->hw_addr, &oam);
-        ofproto_dpif_send_packet(mport->ofport, oam, packet);
+        err = bfd_put_packet(mport->bfd, packet, mport->hw_addr, &ofpacts);
+        if (!err) {
+            ofproto_dpif_send_packet_with_acts(mport->ofport, packet, &ofpacts);
+        }
     }
     if (mport->lldp && lldp_should_send_packet(mport->lldp)) {
         dp_packet_clear(packet);
@@ -307,6 +313,7 @@ monitor_mport_run(struct mport *mport, struct dp_packet *packet)
     next_wake_time = MIN(bfd_wake_time,
                          cfm_wake_time);
     next_wake_time = MIN(next_wake_time, lldp_wake_time);
+
     heap_change(&monitor_heap, &mport->heap_node,
                 MSEC_TO_PRIO(next_wake_time));
 }
diff --git a/ofproto/ofproto-dpif-sflow.c b/ofproto/ofproto-dpif-sflow.c
index e8e1de920..088f5afc1 100644
--- a/ofproto/ofproto-dpif-sflow.c
+++ b/ofproto/ofproto-dpif-sflow.c
@@ -61,7 +61,8 @@ enum dpif_sflow_tunnel_type {
     DPIF_SFLOW_TUNNEL_VXLAN,
     DPIF_SFLOW_TUNNEL_GRE,
     DPIF_SFLOW_TUNNEL_LISP,
-    DPIF_SFLOW_TUNNEL_GENEVE
+    DPIF_SFLOW_TUNNEL_GENEVE,
+    DPIF_SFLOW_TUNNEL_GTP
 };
 
 struct dpif_sflow_port {
@@ -625,6 +626,8 @@ dpif_sflow_tunnel_type(struct ofport *ofport) {
             return DPIF_SFLOW_TUNNEL_LISP;
         } else if (strcmp(type, "geneve") == 0) {
             return DPIF_SFLOW_TUNNEL_GENEVE;
+        } else if (strcmp(type, "gtpu") == 0) {
+            return DPIF_SFLOW_TUNNEL_GTP;
         }
     }
     return DPIF_SFLOW_TUNNEL_UNKNOWN;
@@ -643,6 +646,7 @@ dpif_sflow_tunnel_proto(enum dpif_sflow_tunnel_type tunnel_type)
 
     case DPIF_SFLOW_TUNNEL_VXLAN:
     case DPIF_SFLOW_TUNNEL_LISP:
+    case DPIF_SFLOW_TUNNEL_GTP:
     case DPIF_SFLOW_TUNNEL_GENEVE:
         ipproto = IPPROTO_UDP;
 
diff --git a/ofproto/ofproto-dpif-xlate.c b/ofproto/ofproto-dpif-xlate.c
index c2cc7a38a..7114a1339 100644
--- a/ofproto/ofproto-dpif-xlate.c
+++ b/ofproto/ofproto-dpif-xlate.c
@@ -5756,6 +5756,12 @@ xlate_sample_action(struct xlate_ctx *ctx,
     cookie.flow_sample.obs_point_id = os->obs_point_id;
     cookie.flow_sample.output_odp_port = output_odp_port;
     cookie.flow_sample.direction = os->direction;
+    cookie.flow_sample.flow_metadata = ctx->xin->flow.metadata;
+    cookie.flow_sample.app_name = ctx->xin->flow.regs[10];
+    cookie.flow_sample.pdp_start_epoch = os->pdp_start_epoch;
+    memcpy(&cookie.flow_sample.msisdn, &os->msisdn, 16);
+    memcpy(&cookie.flow_sample.apn_mac_addr, &os->apn_mac_addr, sizeof(struct eth_addr));
+    memcpy(&cookie.flow_sample.apn_name, &os->apn_name, 24);
 
     compose_sample_action(ctx, probability, &cookie, tunnel_out_port, false);
 }
@@ -8210,17 +8216,14 @@ xlate_resume(struct ofproto_dpif *ofproto,
  * May modify 'packet'.
  * Returns 0 if successful, otherwise a positive errno value. */
 int
-xlate_send_packet(const struct ofport_dpif *ofport, bool oam,
-                  struct dp_packet *packet)
+xlate_send_packet_with_acts(const struct ofport_dpif *ofport,
+                  struct dp_packet *packet, struct ofpbuf *ofpacts)
 {
     struct xlate_cfg *xcfg = ovsrcu_get(struct xlate_cfg *, &xcfgp);
     struct xport *xport;
-    uint64_t ofpacts_stub[1024 / 8];
-    struct ofpbuf ofpacts;
     struct flow flow;
 
-    ofpbuf_use_stack(&ofpacts, ofpacts_stub, sizeof ofpacts_stub);
-    /* Use OFPP_NONE as the in_port to avoid special packet processing. */
+
     flow_extract(packet, &flow);
     flow.in_port.ofp_port = OFPP_NONE;
 
@@ -8229,19 +8232,31 @@ xlate_send_packet(const struct ofport_dpif *ofport, bool oam,
         return EINVAL;
     }
 
+    ofpact_put_OUTPUT(ofpacts)->port = xport->ofp_port;
+
+    /* Actions here are not referring to anything versionable (flow tables or
+     * groups) so we don't need to worry about the version here. */
+    return ofproto_dpif_execute_actions(xport->xbridge->ofproto,
+                                        OVS_VERSION_MAX, &flow, NULL,
+                                        ofpacts->data, ofpacts->size, packet);
+}
+
+int
+xlate_send_packet(const struct ofport_dpif *ofport, bool oam,
+                  struct dp_packet *packet)
+{
+    uint64_t ofpacts_stub[1024 / 8];
+    struct ofpbuf ofpacts;
+
+    ofpbuf_use_stack(&ofpacts, ofpacts_stub, sizeof ofpacts_stub);
+    /* Use OFPP_NONE as the in_port to avoid special packet processing. */
     if (oam) {
         const ovs_be16 flag = htons(NX_TUN_FLAG_OAM);
         ofpact_put_set_field(&ofpacts, mf_from_id(MFF_TUN_FLAGS),
                              &flag, &flag);
     }
 
-    ofpact_put_OUTPUT(&ofpacts)->port = xport->ofp_port;
-
-    /* Actions here are not referring to anything versionable (flow tables or
-     * groups) so we don't need to worry about the version here. */
-    return ofproto_dpif_execute_actions(xport->xbridge->ofproto,
-                                        OVS_VERSION_MAX, &flow, NULL,
-                                        ofpacts.data, ofpacts.size, packet);
+    return xlate_send_packet_with_acts(ofport, packet, &ofpacts);
 }
 
 /* Get xbundle for a ofp_port in a ofproto datapath. */
diff --git a/ofproto/ofproto-dpif-xlate.h b/ofproto/ofproto-dpif-xlate.h
index 2ba90e999..2992ebad6 100644
--- a/ofproto/ofproto-dpif-xlate.h
+++ b/ofproto/ofproto-dpif-xlate.h
@@ -222,6 +222,8 @@ enum ofperr xlate_resume(struct ofproto_dpif *,
                          struct ofpbuf *odp_actions, enum slow_path_reason *,
                          struct flow *, struct xlate_cache *);
 int xlate_send_packet(const struct ofport_dpif *, bool oam, struct dp_packet *);
+int xlate_send_packet_with_acts(const struct ofport_dpif *ofport,
+                  struct dp_packet *packet, struct ofpbuf *ofpacts);
 
 void xlate_mac_learning_update(const struct ofproto_dpif *ofproto,
                                ofp_port_t in_port, struct eth_addr dl_src,
diff --git a/ofproto/ofproto-dpif.c b/ofproto/ofproto-dpif.c
index b3e575bcd..94372e67c 100644
--- a/ofproto/ofproto-dpif.c
+++ b/ofproto/ofproto-dpif.c
@@ -5320,6 +5320,23 @@ ofproto_dpif_send_packet(const struct ofport_dpif *ofport, bool oam,
     ovs_mutex_unlock(&ofproto->stats_mutex);
     return error;
 }
+
+int
+ofproto_dpif_send_packet_with_acts(const struct ofport_dpif *ofport, 
+                                   struct dp_packet *packet, struct ofpbuf *ofpacts)
+{
+    struct ofproto_dpif *ofproto = ofproto_dpif_cast(ofport->up.ofproto);
+    int error;
+
+    error = xlate_send_packet_with_acts(ofport, packet, ofpacts);
+
+    ovs_mutex_lock(&ofproto->stats_mutex);
+    ofproto->stats.tx_packets++;
+    ofproto->stats.tx_bytes += dp_packet_size(packet);
+    ovs_mutex_unlock(&ofproto->stats_mutex);
+    return error;
+}
+
 
 /* Return the version string of the datapath that backs up
  * this 'ofproto'.
diff --git a/ofproto/ofproto-dpif.h b/ofproto/ofproto-dpif.h
index d8e0cd37a..23df56220 100644
--- a/ofproto/ofproto-dpif.h
+++ b/ofproto/ofproto-dpif.h
@@ -376,6 +376,8 @@ void ofproto_dpif_send_async_msg(struct ofproto_dpif *,
                                  struct ofproto_async_msg *);
 int ofproto_dpif_send_packet(const struct ofport_dpif *, bool oam,
                              struct dp_packet *);
+int ofproto_dpif_send_packet_with_acts(const struct ofport_dpif *,
+                             struct dp_packet *, struct ofpbuf *ofpacts);
 enum ofperr ofproto_dpif_flow_mod_init_for_learn(
     struct ofproto_dpif *, const struct ofputil_flow_mod *,
     struct ofproto_flow_mod *);
diff --git a/ofproto/tunnel.c b/ofproto/tunnel.c
index 3455ed233..42a458bbd 100644
--- a/ofproto/tunnel.c
+++ b/ofproto/tunnel.c
@@ -437,6 +437,11 @@ tnl_port_send(const struct ofport_dpif *ofport, struct flow *flow,
         flow->tunnel.tun_id = cfg->out_key;
     }
 
+    if (!cfg->out_key_flow && !cfg->out_key_present) {
+        /* since OAM is never set via OVSDB, do not touch that bit. */
+        flow->tunnel.flags &= FLOW_TNL_F_OAM;
+    }
+
     if (cfg->ttl_inherit && is_ip_any(flow)) {
         wc->masks.nw_ttl = 0xff;
         flow->tunnel.ip_ttl = flow->nw_ttl;
@@ -467,6 +472,13 @@ tnl_port_send(const struct ofport_dpif *ofport, struct flow *flow,
         | (cfg->csum ? FLOW_TNL_F_CSUM : 0)
         | (cfg->out_key_present ? FLOW_TNL_F_KEY : 0);
 
+    if (cfg->user_setcsum) {
+       if (cfg->csum) {
+           flow->tunnel.flags |= FLOW_TNL_F_CSUM;
+       } else {
+           flow->tunnel.flags &= ~FLOW_TNL_F_CSUM;
+       }
+    }
     if (cfg->set_egress_pkt_mark) {
         flow->pkt_mark = cfg->egress_pkt_mark;
         wc->masks.pkt_mark = UINT32_MAX;
diff --git a/rhel/etc_sysconfig_network-scripts_ifup-ovs b/rhel/etc_sysconfig_network-scripts_ifup-ovs
index 0955c0e1f..14f133888 100755
--- a/rhel/etc_sysconfig_network-scripts_ifup-ovs
+++ b/rhel/etc_sysconfig_network-scripts_ifup-ovs
@@ -153,6 +153,10 @@ case "$TYPE" in
                 ;;
         OVSTunnel)
                 ifup_ovs_bridge
+
+                if [ "$OVS_TUNNEL_TYPE" = "gtp" ]; then
+                    OVS_TUNNEL_TYPE="gtpu"
+                fi
                 ovs-vsctl -t ${TIMEOUT} \
                         -- --if-exists del-port "$OVS_BRIDGE" "$DEVICE" \
                         -- add-port "$OVS_BRIDGE" "$DEVICE" $OVS_OPTIONS \
diff --git a/tests/automake.mk b/tests/automake.mk
index 269e8b9d2..1bd355b01 100644
--- a/tests/automake.mk
+++ b/tests/automake.mk
@@ -346,7 +346,7 @@ check-kernel: all
 # Testing the out of tree Kernel module
 check-kmod: all
 	$(MAKE) modules_install
-	modprobe -r -a vport-geneve vport-gre vport-lisp vport-stt vport-vxlan openvswitch
+	modprobe -r -a vport-geneve vport-gre vport-lisp vport-stt vport-vxlan vport-gtp openvswitch
 	$(MAKE) check-kernel
 
 check-system-userspace: all
@@ -518,6 +518,9 @@ tests_test_strtok_r_SOURCES = tests/test-strtok_r.c
 noinst_PROGRAMS += tests/test-type-props
 tests_test_type_props_SOURCES = tests/test-type-props.c
 
+noinst_PROGRAMS += tests/test-gtp
+tests_test_gtp_SOURCES = tests/test-gtp.c
+
 # Python tests.
 CHECK_PYFILES = \
 	tests/appctl.py \
@@ -536,7 +539,8 @@ CHECK_PYFILES = \
 	tests/test-unixctl.py \
 	tests/test-vlog.py \
 	tests/uuidfilt.py \
-	tests/sendpkt.py
+	tests/sendpkt.py \
+	tests/gtp-packet.py
 
 EXTRA_DIST += $(CHECK_PYFILES)
 PYCOV_CLEAN_FILES += $(CHECK_PYFILES:.py=.py,cover) .coverage
diff --git a/tests/gtp-packet.py b/tests/gtp-packet.py
new file mode 100644
index 000000000..435c63a70
--- /dev/null
+++ b/tests/gtp-packet.py
@@ -0,0 +1,43 @@
+#! /usr/bin/env python3
+#  /vagrant/scripts/gtp-packet.py fd00::1 fd00::2 2001::1 2001::2 5555 p0
+import time
+
+
+from scapy.contrib.gtp import (
+    GTP_U_Header,
+    GTPEchoRequest,
+    GTPPDUSessionContainer)
+from scapy.all import *
+import sys
+
+no_of_args = 9
+
+if len(sys.argv) != no_of_args:
+    print("missing or more param: expected: %d given: %d" % (no_of_args, len(sys.argv)));
+    exit()
+
+out_src = sys.argv[1]
+out_dst = sys.argv[2]
+in_src = sys.argv[3]
+in_dst = sys.argv[4]
+in_port = sys.argv[5]
+e_dev = sys.argv[6]
+echo = sys.argv[7]
+seq = sys.argv[8]
+
+if out_src.count(':') >= 2:
+    outer_ip_header = IPv6(src=out_src, dst=out_dst)
+else:
+    outer_ip_header = IP(src=out_src, dst=out_dst)
+
+if in_src.count(':') >= 2:
+    inner_ip_header = IPv6(src=in_src, dst=in_dst)
+else:
+    inner_ip_header = IP(src=in_src, dst=in_dst)
+
+if str(echo) == 'True':
+    pkt = Ether()/outer_ip_header/UDP(sport=2152,dport=2152)/GTP_U_Header(S=1,teid=0,seq=int(seq),next_ex=133)/GTPEchoRequest()
+else:
+    pkt = Ether()/outer_ip_header/UDP(sport=2152,dport=2152)/GTP_U_Header(S=1, teid=0,seq=int(seq),next_ex=133)/GTPPDUSessionContainer(type=1, QFI=6)/inner_ip_header/UDP(sport=int(in_port),dport=int(in_port))/Raw(load="Example Payload")
+
+sendp(pkt, iface=e_dev)
\ No newline at end of file
diff --git a/tests/odp.at b/tests/odp.at
index fce6a4f2b..9b5bc66fc 100644
--- a/tests/odp.at
+++ b/tests/odp.at
@@ -325,6 +325,7 @@ pop_vlan
 sample(sample=9.7%,actions(1,2,3,push_vlan(vid=1,pcp=2)))
 set(tunnel(tun_id=0xabcdef1234567890,src=1.1.1.1,dst=2.2.2.2,ttl=64,flags(df|csum|key)))
 set(tunnel(tun_id=0xabcdef1234567890,src=1.1.1.1,dst=2.2.2.2,ttl=64,flags(key)))
+set(tunnel(tun_id=0x0,dst=1.1.1.1,ttl=64,tp_dst=2152,gtpu(ver=0,flags=0x32,msgtype=0x1),flags(df|key))),pop_eth,2152
 tnl_pop(4)
 tnl_push(tnl_port(4),header(size=42,type=3,eth(dst=f8:bc:12:44:34:b6,src=f8:bc:12:46:58:e0,dl_type=0x0800),ipv4(src=1.1.2.88,dst=1.1.2.92,proto=47,tos=0,ttl=64,frag=0x4000),gre((flags=0x2000,proto=0x6558),key=0x1e241)),out_port(1))
 tnl_push(tnl_port(4),header(size=46,type=3,eth(dst=f8:bc:12:44:34:b6,src=f8:bc:12:46:58:e0,dl_type=0x0800),ipv4(src=1.1.2.88,dst=1.1.2.92,proto=47,tos=0,ttl=64,frag=0x4000),gre((flags=0xa000,proto=0x6558),csum=0x0,key=0x1e241)),out_port(1))
diff --git a/tests/ofproto.at b/tests/ofproto.at
index 32bde5b5a..6866c1666 100644
--- a/tests/ofproto.at
+++ b/tests/ofproto.at
@@ -2351,9 +2351,9 @@ head_table () {
       instructions: meter apply_actions clear_actions write_actions write_metadata goto_table
       Write-Actions and Apply-Actions features:
         actions: output group set_field strip_vlan push_vlan mod_nw_ttl dec_ttl set_mpls_ttl dec_mpls_ttl push_mpls pop_mpls set_queue
-        supported on Set-Field: tun_{id,src,dst,ipv6_{src,dst},flags,gbp_{id,flags},erspan_{idx,ver,dir,hwid},metadata0...metadata63} metadata in_{port,port_oxm} pkt_mark ct_{mark,label} reg0...reg15 xreg0...xreg7 xxreg0...xxreg3 eth_{src,dst} vlan_{tci,vid,pcp} mpls_{label,tc,ttl} ip_{src,dst} ipv6_{src,dst,label} nw_tos ip_dscp nw_{ecn,ttl} arp_{op,spa,tpa,sha,tha} tcp_{src,dst} udp_{src,dst} sctp_{src,dst} icmp_{type,code} icmpv6_{type,code} nd_{target,sll,tll,reserved,options_type} nsh_{flags,spi,si,c1...c4,ttl}
+        supported on Set-Field: tun_{id,src,dst,ipv6_{src,dst},flags,gbp_{id,flags},erspan_{idx,ver,dir,hwid},gtpu_{flags,msgtype},metadata0...metadata63} metadata in_{port,port_oxm} pkt_mark ct_{mark,label} reg0...reg15 xreg0...xreg7 xxreg0...xxreg3 eth_{src,dst} vlan_{tci,vid,pcp} mpls_{label,tc,ttl} ip_{src,dst} ipv6_{src,dst,label} nw_tos ip_dscp nw_{ecn,ttl} arp_{op,spa,tpa,sha,tha} tcp_{src,dst} udp_{src,dst} sctp_{src,dst} icmp_{type,code} icmpv6_{type,code} nd_{target,sll,tll,reserved,options_type} nsh_{flags,spi,si,c1...c4,ttl} qfi
     matching:
-      arbitrary mask: dp_hash tun_{id,src,dst,ipv6_{src,dst},flags,gbp_{id,flags},erspan_{idx,ver,dir,hwid},gtpu_{flags,msgtype},metadata0...metadata63} metadata pkt_mark ct_{state,mark,label,nw_{src,dst},ipv6_{src,dst},tp_{src,dst}} reg0...reg15 xreg0...xreg7 xxreg0...xxreg3 eth_{src,dst} vlan_{tci,vid} ip_{src,dst} ipv6_{src,dst,label} ip_frag arp_{spa,tpa,sha,tha} tcp_{src,dst,flags} udp_{src,dst} sctp_{src,dst} nd_{target,sll,tll} nsh_{flags,c1...c4}
+      arbitrary mask: dp_hash tun_{id,src,dst,ipv6_{src,dst},flags,gbp_{id,flags},erspan_{idx,ver,dir,hwid},gtpu_{flags,msgtype},metadata0...metadata63} metadata pkt_mark ct_{state,mark,label,nw_{src,dst},ipv6_{src,dst},tp_{src,dst}} reg0...reg15 xreg0...xreg7 xxreg0...xxreg3 eth_{src,dst} vlan_{tci,vid} ip_{src,dst} ipv6_{src,dst,label} ip_frag arp_{spa,tpa,sha,tha} tcp_{src,dst,flags} udp_{src,dst} sctp_{src,dst} nd_{target,sll,tll} nsh_{flags,c1...c4} qfi
       exact match or wildcard: recirc_id packet_type conj_id in_{port,port_oxm} actset_output ct_{zone,nw_proto} eth_type vlan_pcp mpls_{label,tc,bos,ttl} nw_{proto,tos} ip_dscp nw_{ecn,ttl} arp_op icmp_{type,code} icmpv6_{type,code} nd_{reserved,options_type} nsh_{mdtype,np,spi,si,ttl}
 
 ' "$1"
diff --git a/tests/ovs-router.at b/tests/ovs-router.at
index 6dacc2954..6d6e648a5 100644
--- a/tests/ovs-router.at
+++ b/tests/ovs-router.at
@@ -19,14 +19,15 @@ AT_CHECK([ovs-appctl netdev-dummy/ip4addr br0 192.0.2.1/24], [0], [OK
 ])
 AT_CHECK([ovs-appctl ovs/route/add 198.51.100.0/24 br0 192.0.2.254], [0], [OK
 ])
-AT_CHECK([ovs-appctl ovs/route/add 192.0.2.1/24 br0 pkt_mark=123], [0], [OK
+AT_CHECK([ovs-appctl ovs/route/add 198.0.2.1/24 br0 192.0.2.123 pkt_mark=123], [0], [OK
 ])
 
-AT_CHECK([ovs-appctl ovs/route/add 198.51.100.200/24 br0 192.0.2.250 pkt_mark=1234], [0], [OK
+AT_CHECK([ovs-appctl ovs/route/add 198.0.2.1/24 br0 192.0.2.250 pkt_mark=1234], [0], [OK
 ])
 
-AT_CHECK([ovs-appctl ovs/route/show | grep User | sort], [0], [User: 192.0.2.0/24 MARK 123 dev br0 SRC 192.0.2.1
-User: 198.51.100.0/24 MARK 1234 dev br0 GW 192.0.2.250 SRC 192.0.2.1
+AT_CHECK([ovs-appctl ovs/route/show | grep User | sort], [0], [dnl
+User: 198.0.2.0/24 MARK 123 dev br0 GW 192.0.2.123 SRC 192.0.2.1
+User: 198.0.2.0/24 MARK 1234 dev br0 GW 192.0.2.250 SRC 192.0.2.1
 User: 198.51.100.0/24 dev br0 GW 192.0.2.254 SRC 192.0.2.1
 ])
 
@@ -36,12 +37,22 @@ dev br0
 ])
 
 AT_CHECK([ovs-appctl ovs/route/lookup 198.51.100.1 pkt_mark=1234], [0], [src 192.0.2.1
+gateway 192.0.2.254
+dev br0
+])
+AT_CHECK([ovs-appctl ovs/route/lookup 198.0.2.100 pkt_mark=1234], [0], [src 192.0.2.1
 gateway 192.0.2.250
 dev br0
 ])
-AT_CHECK([ovs-appctl ovs/route/del 198.51.100.0/24 pkt_mark=1234], [0], [OK
+AT_CHECK([ovs-appctl ovs/route/lookup 198.0.2.100 pkt_mark=123], [0], [src 192.0.2.1
+gateway 192.0.2.123
+dev br0
+])
+
+AT_CHECK([ovs-appctl ovs/route/del 198.0.2.0/24 pkt_mark=1234], [0], [OK
 ])
-AT_CHECK([ovs-appctl ovs/route/show | grep User | sort], [0], [User: 192.0.2.0/24 MARK 123 dev br0 SRC 192.0.2.1
+AT_CHECK([ovs-appctl ovs/route/show | grep User | sort], [0], [dnl
+User: 198.0.2.0/24 MARK 123 dev br0 GW 192.0.2.123 SRC 192.0.2.1
 User: 198.51.100.0/24 dev br0 GW 192.0.2.254 SRC 192.0.2.1
 ])
 
@@ -55,12 +66,12 @@ AT_CHECK([ovs-appctl netdev-dummy/ip6addr br0 2001:db8:cafe::1/64], [0], [OK
 ])
 AT_CHECK([ovs-appctl ovs/route/add 2001:db8:babe::/64 br0 2001:db8:cafe::2], [0], [OK
 ])
-AT_CHECK([ovs-appctl ovs/route/add 2001:db8:babe::/64 br0 2001:db8:cafe::3 pkt_mark=321], [0], [OK
+AT_CHECK([ovs-appctl ovs/route/add 2001:db9:babe::/64 br0 2001:db8:cafe::3 pkt_mark=321], [0], [OK
 ])
 
 AT_CHECK([ovs-appctl ovs/route/show | grep User | sort], [0], [dnl
-User: 2001:db8:babe::/64 MARK 321 dev br0 GW 2001:db8:cafe::3 SRC 2001:db8:cafe::1
 User: 2001:db8:babe::/64 dev br0 GW 2001:db8:cafe::2 SRC 2001:db8:cafe::1
+User: 2001:db9:babe::/64 MARK 321 dev br0 GW 2001:db8:cafe::3 SRC 2001:db8:cafe::1
 ])
 
 AT_CHECK([ovs-appctl ovs/route/lookup 2001:db8:babe::1eaf], [0], [src 2001:db8:cafe::1
@@ -68,12 +79,12 @@ gateway 2001:db8:cafe::2
 dev br0
 ])
 
-AT_CHECK([ovs-appctl ovs/route/lookup 2001:db8:babe::1eaf pkt_mark=321], [0], [src 2001:db8:cafe::1
+AT_CHECK([ovs-appctl ovs/route/lookup 2001:db9:babe::1eaf pkt_mark=321], [0], [src 2001:db8:cafe::1
 gateway 2001:db8:cafe::3
 dev br0
 ])
 
-AT_CHECK([ovs-appctl ovs/route/del 2001:db8:babe::/64 pkt_mark=321], [0], [OK
+AT_CHECK([ovs-appctl ovs/route/del 2001:db9:babe::/64 pkt_mark=321], [0], [OK
 ])
 AT_CHECK([ovs-appctl ovs/route/show | grep User | sort], [0], [dnl
 User: 2001:db8:babe::/64 dev br0 GW 2001:db8:cafe::2 SRC 2001:db8:cafe::1
diff --git a/tests/system-common-macros.at b/tests/system-common-macros.at
index 8b9f5c752..04c3d9414 100644
--- a/tests/system-common-macros.at
+++ b/tests/system-common-macros.at
@@ -160,6 +160,25 @@ m4_define([ADD_CVLAN],
     ]
 )
 
+# ADD_OVS_TUNNEL_NO_REMOTE([type], [bridge], [port], [overlay-addr],
+#                [tunnel-args])
+#
+# Add an ovs-based tunnel device in the root namespace, with name 'port' and
+# type 'type'. The tunnel device will be configured as point-to-point with the
+# 'remote-addr' as the underlay address of the remote tunnel endpoint.
+#
+# 'port will be configured with the address 'overlay-addr'.
+#
+m4_define([ADD_OVS_TUNNEL_NO_REMOTE],
+   [AT_CHECK([ovs-vsctl add-port $2 $3 -- \
+              set int $3 type=$1 options:remote_ip=flow $5])
+    AT_CHECK([ip addr add dev $2 $4])
+    AT_CHECK([ip link set dev $2 up])
+    AT_CHECK([ip link set dev $2 mtu 1450])
+    on_exit 'ip addr del dev $2 $4'
+   ]
+)
+
 # ADD_OVS_TUNNEL([type], [bridge], [port], [remote-addr], [overlay-addr],
 #                [tunnel-args])
 #
@@ -331,6 +350,13 @@ m4_define([OVS_CHECK_GENEVE_UDP6ZEROCSUM],
     [AT_SKIP_IF([! ip link add foo type geneve help 2>&1 | grep udp6zerocsum >/dev/null])
      OVS_CHECK_FIREWALL()])
 
+# OVS_CHECK_GTP_L3()
+# GTP Unit test depends on http://git.osmocom.org/libgtpnl/
+m4_define([OVS_CHECK_GTP_L3],
+    [AT_SKIP_IF([! gtp-tunnel list >/dev/null])
+     OVS_CHECK_FIREWALL()])
+
+
 # OVS_CHECK_8021AD()
 m4_define([OVS_CHECK_8021AD],
     [AT_SKIP_IF([! grep -q "VLAN header stack length probed as" ovs-vswitchd.log])
diff --git a/tests/system-layer3-tunnels.at b/tests/system-layer3-tunnels.at
index 5ee013e0a..620020b4f 100644
--- a/tests/system-layer3-tunnels.at
+++ b/tests/system-layer3-tunnels.at
@@ -54,6 +54,7 @@ OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:b
 OVS_CHECK_GRE_L3()
 OVS_CHECK_IPROUTE_ENCAP()
 
+
 ADD_BR([br-underlay])
 
 ADD_NAMESPACES(at_ns0)
@@ -246,5 +247,910 @@ NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING], [0],
 NS_CHECK_EXEC([at_ns1], [ping -q -c 3 -i 0.3 -w 2 10.1.1.1 | FORMAT_PING], [0], [dnl
 3 packets transmitted, 3 received, 0% packet loss, time 0ms
 ])
+
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([layer3 - ping over GTP])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+OVS_CHECK_GTP_L3()
+OVS_CHECK_MIN_KERNEL(4,10)
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
+AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
+AT_CHECK([ip link set dev br-underlay up])
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [172.31.1.1], [10.1.1.2/24])
+AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
+NS_CHECK_EXEC([at_ns0], [gtp-link add at_gtp1 --sgsn &], [0], [ignore])
+dnl kernel 4.9
+dnl NS_CHECK_EXEC([at_ns0], [gtp-tunnel add at_gtp1 v1 0 0 10.1.1.2 172.31.1.100], [0], [ignore], [ignore])
+NS_CHECK_EXEC([at_ns0], [gtp-tunnel add at_gtp1 v1 0 0 10.1.1.1 172.31.1.100], [0], [ignore], [ignore])
+NS_CHECK_EXEC([at_ns0], [ip addr add dev at_gtp1 10.1.1.1/24])
+NS_CHECK_EXEC([at_ns0], [ip link set dev at_gtp1 mtu 1450 up])
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+dnl Now add rules for OVS to forward to the tunnel and local port
+AT_CHECK([ovs-ofctl add-flow br0 "priority=1 action=drop"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,nw_dst=10.1.1.1 action=output:at_gtp0"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,nw_dst=10.1.1.2 action=mod_dl_src:00:12:34:56:78:aa,mod_dl_dst:00:12:34:56:78:bb,local"])
+
+
+dnl First, check the underlay
+NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 172.31.1.100 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+
+OVS_WAIT_UNTIL([ip netns exec at_ns0 ping -c 1 10.1.1.2])
+dnl Okay, now check the overlay with different packet sizes
+NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+NS_CHECK_EXEC([at_ns0], [ping -s 3200 -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:enable=true])
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:min_tx=5000 bfd:min_rx=5000])
+
+sleep 2
+NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+NS_CHECK_EXEC([at_ns0], [ping -s 3200 -q -c 3 -i 0.3 -w 2 10.1.1.2 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+
+dnl sleep 10000
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([layer3 - IPv6 packets over IPv6 GTP])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+OVS_CHECK_GTP_L3()
+OVS_CHECK_MIN_KERNEL(4,10)
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "fc00::55:0:111/48")
+AT_CHECK([ip -6 addr add dev br-underlay "fc00::55:0:211/48"])
+AT_CHECK([ip -6 link set dev br-underlay up])
+
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [fc00::55:0:111], [2001::2/64])
+AT_CHECK([ip -6 neigh add 2001::1 lladdr 00:12:34:56:78:aa dev br0])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev lo up])
+NS_CHECK_EXEC([at_ns0], [ip -6 addr add dev lo 2005:cafe::92/64])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+dnl Now add rules for OVS to forward to the tunnel and local port
+AT_CHECK([ovs-ofctl add-flow br0 "priority=1 action=drop"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip6,ipv6_dst=2001::1 action=output:at_gtp0"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip6,ipv6_dst=2001::2 action=drop"])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | grep "ipv6" | ofctl_strip], [0], [dnl
+ priority=100,ipv6,ipv6_dst=2001::1 actions=output:1
+ priority=100,ipv6,ipv6_dst=2001::2 actions=drop
+])
+
+sleep 1
+NS_CHECK_EXEC([at_ns0], [python3 $srcdir/gtp-packet.py fc00::55:0:111 fc00::55:0:211 2001::1 2001::2 5555 p0 False 1234 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | grep ipv6 ], [0], [dnl
+ priority=100,ipv6,ipv6_dst=2001::1 actions=output:1
+ n_packets=1, n_bytes=63, priority=100,ipv6,ipv6_dst=2001::2 actions=drop
+])
+
+NS_CHECK_EXEC([at_ns0], [tcpdump -l -n -xx -U ip6 host fc00::55:0:111 -i p0 > ipv6_xmit.pcap  2>/dev/null &])
+
+sleep 1
+AT_CHECK([ping -6 2001::1 -q -c 3 -I br0 2>/dev/null | FORMAT_PING], [0], [dnl
+3 packets transmitted, 0 received, 100% packet loss, time 0ms
+])
+
+OVS_WAIT_UNTIL([cat ipv6_xmit.pcap | egrep "IP6 fc00::55:0:211.2152 > fc00::55:0:111.2152: UDP, length 112" 2>&1 1>/dev/null])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | grep ipv6 ], [0], [dnl
+ n_packets=3, n_bytes=354, priority=100,ipv6,ipv6_dst=2001::1 actions=output:1
+ n_packets=1, n_bytes=63, priority=100,ipv6,ipv6_dst=2001::2 actions=drop
+])
+
+dnl sleep 1000
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([layer3 - IPv6 packets over IPv4 GTP])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+OVS_CHECK_GTP_L3()
+OVS_CHECK_MIN_KERNEL(4,10)
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
+AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
+AT_CHECK([ip link set dev br-underlay up])
+
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [172.31.1.1], [2001::2/64])
+AT_CHECK([ip -6 neigh add 2001::1 lladdr 00:12:34:56:78:aa dev br0])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev lo up])
+NS_CHECK_EXEC([at_ns0], [ip -6 addr add dev lo 2005:cafe::92/64])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+dnl Now add rules for OVS to forward to the tunnel and local port
+AT_CHECK([ovs-ofctl add-flow br0 "priority=1 action=drop"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip6,ipv6_dst=2001::1 action=output:at_gtp0"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip6,ipv6_dst=2001::2 action=drop"])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | grep "ipv6" | ofctl_strip], [0], [dnl
+ priority=100,ipv6,ipv6_dst=2001::1 actions=output:1
+ priority=100,ipv6,ipv6_dst=2001::2 actions=drop
+])
+
+sleep 1
+NS_CHECK_EXEC([at_ns0], [python3 $srcdir/gtp-packet.py 172.31.1.1 172.31.1.100 2001::1 2001::2 5555 p0 False 1234 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | grep ipv6 ], [0], [dnl
+ priority=100,ipv6,ipv6_dst=2001::1 actions=output:1
+ n_packets=1, n_bytes=63, priority=100,ipv6,ipv6_dst=2001::2 actions=drop
+])
+
+NS_CHECK_EXEC([at_ns0], [tcpdump -l -n -xx -U ip host 172.31.1.1 -i p0 > ipv6_xmit.pcap  2>/dev/null &])
+
+sleep 1
+AT_CHECK([ping -6 2001::1 -q -c 3 -I br0 2>/dev/null | FORMAT_PING], [0], [dnl
+3 packets transmitted, 0 received, 100% packet loss, time 0ms
+])
+
+OVS_WAIT_UNTIL([cat ipv6_xmit.pcap | egrep "IP 172.31.1.100.2152 > 172.31.1.1.2152: UDP, length 112" 2>&1 1>/dev/null])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | grep ipv6 ], [0], [dnl
+ n_packets=3, n_bytes=354, priority=100,ipv6,ipv6_dst=2001::1 actions=output:1
+ n_packets=1, n_bytes=63, priority=100,ipv6,ipv6_dst=2001::2 actions=drop
+])
+
+dnl sleep 1000
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+
+AT_SETUP([layer3 - IPv4 packets over IPv6 GTP])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+OVS_CHECK_GTP_L3()
+OVS_CHECK_MIN_KERNEL(4,10)
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "fc00::55:0:111/48")
+AT_CHECK([ip -6 addr add dev br-underlay "fc00::55:0:211/48"])
+AT_CHECK([ip -6 link set dev br-underlay up])
+
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [fc00::55:0:111], [10.1.1.2/24])
+AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
+
+dnl NS_CHECK_EXEC([at_ns0], [ip link set dev lo up])
+dnl NS_CHECK_EXEC([at_ns0], [ip -6 addr add dev lo 2005:cafe::92/64])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+dnl Now add rules for OVS to forward to the tunnel and local port
+AT_CHECK([ovs-ofctl add-flow br0 "priority=1 action=drop"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,ip_dst=10.1.1.1 action=output:at_gtp0"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,ip_dst=10.1.1.2 action=drop"])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | grep "ip" | ofctl_strip], [0], [dnl
+ priority=100,ip,nw_dst=10.1.1.1 actions=output:1
+ priority=100,ip,nw_dst=10.1.1.2 actions=drop
+])
+
+sleep 1
+NS_CHECK_EXEC([at_ns0], [python3 $srcdir/gtp-packet.py fc00::55:0:111 fc00::55:0:211 10.1.1.1 10.1.1.2 5555 p0 False 1234 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | grep ip ], [0], [dnl
+ priority=100,ip,nw_dst=10.1.1.1 actions=output:1
+ n_packets=1, n_bytes=43, priority=100,ip,nw_dst=10.1.1.2 actions=drop
+])
+
+NS_CHECK_EXEC([at_ns0], [tcpdump -l -n -xx -U ip6 host fc00::55:0:111 -i p0 > ipv6_xmit.pcap  2>/dev/null &])
+
+sleep 1
+AT_CHECK([ping  10.1.1.1 -q -c 3 -I br0 2>/dev/null | FORMAT_PING], [0], [dnl
+3 packets transmitted, 0 received, 100% packet loss, time 0ms
+])
+
+OVS_WAIT_UNTIL([cat ipv6_xmit.pcap | egrep "IP6 fc00::55:0:211.2152 > fc00::55:0:111.2152: UDP, length 92" 2>&1 1>/dev/null])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | grep ip ], [0], [dnl
+ n_packets=3, n_bytes=294, priority=100,ip,nw_dst=10.1.1.1 actions=output:1
+ n_packets=1, n_bytes=43, priority=100,ip,nw_dst=10.1.1.2 actions=drop
+])
+
+dnl sleep 1000
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([layer3 - GTP echo match test])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
+AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
+AT_CHECK([ip link set dev br-underlay up])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+AT_CHECK([modprobe vport_gtp])
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [172.31.1.1], [10.1.1.2/24])
+AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 in_port=at_gtp0,tun_gtpu_msgtype=1,tun_gtpu_flags=0x32 action=drop"])
+
+dnl First, check the underlay
+NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 172.31.1.100 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+
+dnl AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+dnl AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+NS_CHECK_EXEC([at_ns0], [test-gtp 172.31.1.100 3201000a0000000000010000ff0003000a01], [0], [ignore])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | grep gtpu], [0], [dnl
+ n_packets=1, n_bytes=10, priority=100,gtpu_flags=0x32,gtpu_msgtype=1,in_port=1 actions=drop
+])
+
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([layer3 - IPv6 GTP echo match test])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+OVS_CHECK_GTP_L3()
+OVS_CHECK_MIN_KERNEL(4,10)
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "fc00::55:0:111/48")
+AT_CHECK([ip -6 addr add dev br-underlay "fc00::55:0:211/48"])
+AT_CHECK([ip -6 link set dev br-underlay up])
+
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [fc00::55:0:111], [2001::2/64])
+AT_CHECK([ip -6 neigh add 2001::1 lladdr 00:12:34:56:78:aa dev br0])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev lo up])
+NS_CHECK_EXEC([at_ns0], [ip -6 addr add dev lo 2005:cafe::92/64])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 in_port=at_gtp0,tun_gtpu_msgtype=1,tun_gtpu_flags=0x32 action=drop"])
+
+sleep 1
+NS_CHECK_EXEC([at_ns0], [python3 $srcdir/gtp-packet.py fc00::55:0:111 fc00::55:0:211 2001::1 2001::2 5555 p0 True 1234 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+
+AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | grep gtpu], [0], [dnl
+ n_packets=1, n_bytes=4, priority=100,gtpu_flags=0x32,gtpu_msgtype=1,in_port=1 actions=drop
+])
+
+dnl sleep 1000
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+
+AT_SETUP([layer3 - GTP echo response test])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
+AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
+AT_CHECK([ip link set dev br-underlay up])
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [172.31.1.1], [10.1.1.2/24], [options:local_ip=172.31.1.100])
+AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:min_tx=5000 bfd:min_rx=5000])
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:enable=true])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+dnl sleep 1000
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points], [0], [dnl
+Tunnel port: at_gtp0
+])  
+
+NS_CHECK_EXEC([at_ns0], [test-gtp 172.31.1.100 3201000a0000000000010000ff0003000a01], [0], [ignore])
+sleep 1
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 1 TX: 1 remote ip: 172.31.1.1, seq 1, pending send 0
+])  
+
+NS_CHECK_EXEC([at_ns0], [tcpdump -l -n -xx -U udp -i p0 > p1.pcap &])
+sleep 1
+
+NS_CHECK_EXEC([at_ns0], [test-gtp 172.31.1.100 3201000a0000000000030000ff0003000a01], [0], [ignore])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 2 TX: 2 remote ip: 172.31.1.1, seq 3, pending send 0
+])
+dnl sleep 1000
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "IP 172.31.1.100.2152 > 172.31.1.1.2152: UDP, length 14" 2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0000:.*0800 4500"                                     2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0010:.*ac1f 0164 ac1f"       2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0020:  0101 0868 0868 0016 0000 3202 0006 0000"       2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0030:  0000 0003 0000 0e00"                           2>&1 1>/dev/null])
+ 
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+
+AT_SETUP([layer3 - IPv6 GTP echo response test])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "fc00::55:0:111/48")
+AT_CHECK([ip -6 addr add dev br-underlay "fc00::55:0:211/48"])
+AT_CHECK([ip -6 link set dev br-underlay up])
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [fc00::55:0:111], [2001::2/64], [options:local_ip=fc00::55:0:211])
+AT_CHECK([ip -6 neigh add 2001::1 lladdr 00:12:34:56:78:aa dev br0])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:min_tx=5000 bfd:min_rx=5000])
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:enable=true])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev lo up])
+NS_CHECK_EXEC([at_ns0], [ip -6 addr add dev lo 2005:cafe::92/64])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+dnl sleep 1000
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points], [0], [dnl
+Tunnel port: at_gtp0
+])
+
+sleep 1
+NS_CHECK_EXEC([at_ns0], [python3 $srcdir/gtp-packet.py fc00::55:0:111 fc00::55:0:211 2001::1 2001::2 5555 p0 True 1 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+sleep 1
+
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 1 TX: 1 remote ip: 0.0.0.0, seq 1, pending send 0
+])
+
+NS_CHECK_EXEC([at_ns0], [tcpdump -l -n -xx -U udp -i p0 > p1.pcap &])
+sleep 1
+
+NS_CHECK_EXEC([at_ns0], [python3 $srcdir/gtp-packet.py fc00::55:0:111 fc00::55:0:211 2001::1 2001::2 5555 p0 True 3 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 2 TX: 2 remote ip: 0.0.0.0, seq 3, pending send 0
+])
+
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "IP6 fc00::55:0:111.2152 > fc00::55:0:211.2152: UDP, length 12" 2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0000:.*86dd 6000"                                     2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0010:.*0000 0000 0000"       2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0020:  0055 0000 0111 fc00 0000 0000 0000 0000"       2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0030:  0055 0000 0211 0868 0868 0014 c09b 3201"                                2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0040:  0004 0000 0000 0003 0085"                                2>&1 1>/dev/null])
+
+dnl sleep 1000
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([layer3 - GTP echo response test multi endpoint])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+ADD_NAMESPACES(at_ns1)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
+ADD_VETH(p1, at_ns1, br-underlay, "172.31.1.2/24")
+AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
+AT_CHECK([ip link set dev br-underlay up])
+
+AT_CHECK([modprobe vport_gtp])
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [172.31.1.1], [10.1.1.2/24])
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp1], [172.31.1.2], [10.1.2.2/24])
+
+AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+NS_CHECK_EXEC([at_ns1], [ip link set dev p1 mtu 1480 up])
+
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:min_tx=5000 bfd:min_rx=5000])
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:enable=true])
+AT_CHECK([ovs-vsctl set interface at_gtp1 bfd:enable=false])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points], [0], [dnl
+Tunnel port: at_gtp0
+Tunnel port: at_gtp1
+])  
+
+NS_CHECK_EXEC([at_ns0], [test-gtp 172.31.1.100 3201000a0000000000010000ff0003000a01], [0], [ignore])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 1 TX: 1 remote ip: 172.31.1.1, seq 1, pending send 0
+Tunnel port: at_gtp1
+])  
+
+NS_CHECK_EXEC([at_ns1], [test-gtp 172.31.1.100 3201000a0000000000030000ff0003000a01], [0], [ignore])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 1 TX: 1 remote ip: 172.31.1.1, seq 1, pending send 0
+Tunnel port: at_gtp1
+])  
+
+AT_CHECK([ovs-vsctl set interface at_gtp1 bfd:min_tx=5000 bfd:min_rx=5000])
+AT_CHECK([ovs-vsctl set interface at_gtp1 bfd:enable=true])
+
+NS_CHECK_EXEC([at_ns1], [test-gtp 172.31.1.100 3201000a0000000000030000ff0003000a01], [0], [ignore])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+Tunnel port: at_gtp1
+RX: 1 TX: 1 remote ip: 172.31.1.2, seq 3, pending send 0
+])  
+
+
+NS_CHECK_EXEC([at_ns0], [test-gtp 172.31.1.100 3201000a0000000000040000ff0003000a01], [0], [ignore])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 1 TX: 1 remote ip: 172.31.1.1, seq 4, pending send 0
+Tunnel port: at_gtp1
+RX: 1 TX: 1 remote ip: 172.31.1.2, seq 3, pending send 0
+])  
+
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+
+AT_SETUP([layer3 - IPv6 GTP echo response test multi endpoint])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+ADD_NAMESPACES(at_ns1)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "fc00::55:0:111/48")
+ADD_VETH(p1, at_ns1, br-underlay, "fc00::55:0:112/48")
+AT_CHECK([ip -6 addr add dev br-underlay "fc00::55:0:211/48"])
+AT_CHECK([ip -6 link set dev br-underlay up])
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [fc00::55:0:111], [2001::2/64], [options:local_ip=fc00::55:0:211])
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp1], [fc00::55:0:112], [2021::2/64], [options:local_ip=fc00::55:0:211])
+
+AT_CHECK([ip -6 neigh add 2001::1 lladdr 00:12:34:56:78:aa dev br0])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+NS_CHECK_EXEC([at_ns1], [ip link set dev p1 mtu 1480 up])
+
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:min_tx=5000 bfd:min_rx=5000])
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:enable=true])
+AT_CHECK([ovs-vsctl set interface at_gtp1 bfd:enable=false])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points], [0], [dnl
+Tunnel port: at_gtp0
+Tunnel port: at_gtp1
+])
+
+sleep 1
+NS_CHECK_EXEC([at_ns0], [python3 $srcdir/gtp-packet.py fc00::55:0:111 fc00::55:0:211 2001::1 2001::2 5555 p0 True 1 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 1 TX: 1 remote ip: 0.0.0.0, seq 1, pending send 0
+Tunnel port: at_gtp1
+])
+
+NS_CHECK_EXEC([at_ns1], [python3 $srcdir/gtp-packet.py fc00::55:0:112 fc00::55:0:211 2001::1 2001::2 5555 p1 True 1 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 1 TX: 1 remote ip: 0.0.0.0, seq 1, pending send 0
+Tunnel port: at_gtp1
+])
+
+AT_CHECK([ovs-vsctl set interface at_gtp1 bfd:min_tx=5000 bfd:min_rx=5000])
+AT_CHECK([ovs-vsctl set interface at_gtp1 bfd:enable=true])
+
+NS_CHECK_EXEC([at_ns1], [python3 $srcdir/gtp-packet.py fc00::55:0:112 fc00::55:0:211 2001::1 2001::2 5555 p1 True 3 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+Tunnel port: at_gtp1
+RX: 1 TX: 1 remote ip: 0.0.0.0, seq 3, pending send 0
+])
+
+
+NS_CHECK_EXEC([at_ns0], [python3 $srcdir/gtp-packet.py fc00::55:0:111 fc00::55:0:211 2001::1 2001::2 5555 p0 True 4 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+sleep 2
+AT_CHECK([ovs-appctl tnl/gtp_echo_remote_end_points | sed -e  's/^.*: RX/RX/'], [0], [dnl
+Tunnel port: at_gtp0
+RX: 1 TX: 1 remote ip: 0.0.0.0, seq 4, pending send 0
+Tunnel port: at_gtp1
+RX: 1 TX: 1 remote ip: 0.0.0.0, seq 3, pending send 0
+])
+
+dnl sleep 1000
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+
+AT_SETUP([layer3 - GTP end marker test])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+OVS_CHECK_GTP_L3()
+OVS_CHECK_MIN_KERNEL(4,10)
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
+AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
+AT_CHECK([ip link set dev br-underlay up])
+
+AT_CHECK([modprobe vport_gtp])
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [172.31.1.1], [10.1.1.2/24], [options:key=flow])
+AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
+NS_CHECK_EXEC([at_ns0], [gtp-link add at_gtp1 --sgsn &], [0], [ignore])
+dnl for 4.9
+dnl NS_CHECK_EXEC([at_ns0], [gtp-tunnel add at_gtp1 v1 0 0 10.1.1.2 172.31.1.100], [0], [ignore], [ignore])
+NS_CHECK_EXEC([at_ns0], [gtp-tunnel add at_gtp1 v1 0 0 10.1.1.1 172.31.1.100], [0], [ignore], [ignore])
+NS_CHECK_EXEC([at_ns0], [ip addr add dev at_gtp1 10.1.1.1/24])
+NS_CHECK_EXEC([at_ns0], [ip link set dev at_gtp1 mtu 1450 up])
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+AT_CHECK([echo 'module gtp +p' > /sys/kernel/debug/dynamic_debug/control])
+sleep 1
+
+dnl Now add rules for OVS to forward to the tunnel and local port
+AT_CHECK([ovs-ofctl add-flow br0 "priority=1 action=drop"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,nw_dst=10.1.1.1 action=output:at_gtp0"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,nw_dst=10.1.1.2 action=mod_dl_src:00:12:34:56:78:aa,mod_dl_dst:00:12:34:56:78:bb,local"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 table=99,action=set_field:0xfe->tun_gtpu_msgtype,set_field:0x30->tun_gtpu_flags,output:at_gtp0"])
+
+dnl First, check the underlay
+NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 172.31.1.100 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+
+OVS_WAIT_UNTIL([ip netns exec at_ns0 ping -c 1 10.1.1.2])
+
+NS_CHECK_EXEC([at_ns0], [tcpdump -l -n -xx -U udp -i p0 > p1.pcap &])
+sleep 1
+
+AT_CHECK([ovs-ofctl -O OpenFlow15 packet-out br0 "in_port=local packet=50540000000a5054000000008000, actions=load:100->tun_id[[0..31]],set_field:172.31.1.1->tun_dst,set_field:0xfe->tun_gtpu_msgtype,set_field:0x30->tun_gtpu_flags,output:at_gtp0"])
+
+sleep 2
+
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0000:.*0800 4500"                                2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0010:.*ac1f 0164 ac1f"                           2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0020:  0101 0868 0868 0010 0000 30fe 0000 0000"  2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0030:  0064"                                     2>&1 1>/dev/null])
+
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+
+AT_SETUP([layer3 - IPv6 GTP end marker test])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+OVS_CHECK_GTP_L3()
+OVS_CHECK_MIN_KERNEL(4,10)
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "fc00::55:0:111/48")
+AT_CHECK([ip -6 addr add dev br-underlay "fc00::55:0:211/48"])
+AT_CHECK([ip -6 link set dev br-underlay up])
+dnl NS_CHECK_EXEC([at_ns0], [ip -6 route add default dev p0 via fc00::55:0:211])
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [fc00::55:0:111], [2001::2/64], [options:local_ip=fc00::55:0:211])
+AT_CHECK([ip -6 neigh add 2001::1 lladdr 00:12:34:56:78:aa dev br0])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:min_tx=5000 bfd:min_rx=5000])
+AT_CHECK([ovs-vsctl set interface at_gtp0 bfd:enable=true])
+
+NS_CHECK_EXEC([at_ns0], [ip link set dev lo up])
+NS_CHECK_EXEC([at_ns0], [ip -6 addr add dev lo 2005:cafe::92/64])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+
+dnl Now add rules for OVS to forward to the tunnel and local port
+AT_CHECK([ovs-ofctl add-flow br0 "priority=1 action=drop"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip6,ipv6_dst=2001::1 action=output:at_gtp0"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip6,ipv6_dst=2001::2 action=mod_dl_src:00:12:34:56:78:aa,mod_dl_dst:00:12:34:56:78:bb,local"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 table=99,action=set_field:0xfe->tun_gtpu_msgtype,set_field:0x30->tun_gtpu_flags,output:at_gtp0"])
+
+
+NS_CHECK_EXEC([at_ns0], [python3 $srcdir/gtp-packet.py fc00::55:0:111 fc00::55:0:211 2001::1 2001::2 5555 p0 False 1234 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+sleep 1
+
+NS_CHECK_EXEC([at_ns0], [tcpdump -l -n -xx -U udp -i p0 > p1.pcap &])
+sleep 1
+
+AT_CHECK([ovs-ofctl -O OpenFlow15 packet-out br0 "in_port=local packet=50540000000a5054000000008000, actions=load:100->tun_id[[0..31]],set_field:fc00::55:0:111->tun_ipv6_dst,set_field:0xfe->tun_gtpu_msgtype,set_field:0x30->tun_gtpu_flags,output:at_gtp0"])
+
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0030:  0055 0000 0111 0868 0868 0010 0000 30fe"  2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0040:  0000 0000 0000" 2>&1 1>/dev/null])
+
+dnl sleep 1000
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+
+AT_SETUP([layer3 - Qfi value set for uplink over GTP])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+OVS_CHECK_GTP_L3()
+OVS_CHECK_MIN_KERNEL(4,10)
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
+AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
+AT_CHECK([ip link set dev br-underlay up])
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [172.31.1.1], [10.1.1.2/24])
+AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
+dnl kernel 4.9
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+dnl Now add rules with qfi for OVS to forward to the tunnel and local port
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,tun_id=0,nw_dst=10.1.1.2,qfi=6 action=output:at_gtp0"])
+dnl Now add rules for OVS to forward to the tunnel and local port
+AT_CHECK([ovs-ofctl add-flow br0 "priority=1 action=drop"])
+
+sleep 1
+NS_CHECK_EXEC([at_ns0], [python3 $srcdir/gtp-packet.py 172.31.1.1 172.31.1.100 10.1.1.1 10.1.1.2 5555 p0 False 1234 2>/dev/null], [0], [dnl
+.
+Sent 1 packets.
+])
+sleep 1
+
+AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | grep ip], [0], [dnl
+ n_packets=1, n_bytes=43, priority=100,ip,tun_id=0,qfi=6,nw_dst=10.1.1.2 actions=output:1
+])
+dnl sleep 10000
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
+
+
+AT_SETUP([layer3 - Qfi value set for downlink over GTP])
+OVS_TRAFFIC_VSWITCHD_START([set Bridge br0 other-config:hwaddr="00:12:34:56:78:bb"])
+OVS_CHECK_GTP_L3()
+OVS_CHECK_MIN_KERNEL(4,10)
+
+ADD_BR([br-underlay])
+
+ADD_NAMESPACES(at_ns0)
+
+dnl Set up underlay link from host into the namespace using veth pair.
+ADD_VETH(p0, at_ns0, br-underlay, "172.31.1.1/24")
+AT_CHECK([ip addr add dev br-underlay "172.31.1.100/24"])
+AT_CHECK([ip link set dev br-underlay up])
+AT_CHECK([modprobe vport_gtp])
+
+dnl Set up tunnel endpoints on OVS outside the namespace and with a native
+dnl linux device inside the namespace.
+ADD_OVS_TUNNEL([gtpu], [br0], [at_gtp0], [172.31.1.1], [10.1.1.2/24], [options:key=flow])
+AT_CHECK([ip neigh add 10.1.1.1 lladdr 00:12:34:56:78:aa dev br0])
+NS_CHECK_EXEC([at_ns0], [gtp-link add at_gtp1 --sgsn &], [0], [ignore])
+dnl for 4.9
+NS_CHECK_EXEC([at_ns0], [gtp-tunnel add at_gtp1 v1 0 0 10.1.1.1 172.31.1.100], [0], [ignore], [ignore])
+NS_CHECK_EXEC([at_ns0], [ip addr add dev at_gtp1 10.1.1.1/24])
+NS_CHECK_EXEC([at_ns0], [ip link set dev at_gtp1 mtu 1450 up])
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 mtu 1480 up])
+
+AT_CHECK([ovs-ofctl add-flow br-underlay "actions=normal"])
+
+AT_CHECK([ovs-appctl vlog/set dbg], [0], [ignore])
+AT_CHECK([echo 'module openvswitch +p' > /sys/kernel/debug/dynamic_debug/control])
+
+dnl Now add rules with qfi for OVS to forward to the tunnel and local port
+AT_CHECK([ovs-ofctl add-flow br0 "priority=1 action=drop"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,nw_dst=10.1.1.1 action=output:at_gtp0"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 ip,nw_dst=10.1.1.2 action=mod_dl_src:00:12:34:56:78:aa,mod_dl_dst:00:12:34:56:78:bb,local"])
+AT_CHECK([ovs-ofctl add-flow br0 "priority=100 table=99,action=set_field:0->tun_id,set_field:0x1->tun_flags,set_field:0x6->qfi,output:at_gtp0"])
+
+sleep 1
+
+NS_CHECK_EXEC([at_ns0], [ping -q -c 3 -i 0.3 -w 2 172.31.1.100 | FORMAT_PING], [0], [dnl
+3 packets transmitted, 3 received, 0% packet loss, time 0ms
+])
+
+OVS_WAIT_UNTIL([ip netns exec at_ns0 ping -c 1 10.1.1.2])
+
+NS_CHECK_EXEC([at_ns0], [tcpdump -l -n -xx -U udp -i p0 > p1.pcap &])
+sleep 2
+
+AT_CHECK([ovs-ofctl -O OpenFlow15 packet-out br0 "in_port=local packet=50540000000a5054000000008000, actions=set_field:0->tun_id,set_field:172.31.1.1->tun_dst,set_field:0x1->tun_flags,set_field:0x6->qfi,output:at_gtp0"])
+sleep 2
+
+
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0000:.*0800 4500"                                2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0010:.*ac1f 0164 ac1f"                           2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0020:  0101 0868 0868 0018 0000 34ff 0008 0000"  2>&1 1>/dev/null])
+OVS_WAIT_UNTIL([cat p1.pcap | egrep "0x0030:.*0085 0100 0600"                           2>&1 1>/dev/null])
+
+dnl sleep 10000
 OVS_TRAFFIC_VSWITCHD_STOP
 AT_CLEANUP
+
diff --git a/tests/test-gtp.c b/tests/test-gtp.c
new file mode 100644
index 000000000..eb1c4e57c
--- /dev/null
+++ b/tests/test-gtp.c
@@ -0,0 +1,111 @@
+#include <config.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#define DST_PORT  2152
+#define SRC_PORT  2152
+
+
+static int
+charToHex(char ch)
+{
+        if (ch >= 'A' && ch <= 'F') {
+                return 10 + (ch - 'A');
+        }
+        if (ch >= 'a' && ch <= 'f') {
+                return 10 + (ch - 'a');
+        }
+        if (ch >= '0' && ch <= '9') {
+                return ch - '0';
+        }
+        return -1;
+}
+
+int
+main(int argc, char *argv[])
+{
+    struct sockaddr_in addr, srcaddr;
+    int fd;
+    unsigned char *msg;
+    char *str_buf;
+    char *dst_ip;
+    int len, i, j;
+
+    if (argc != 3) {
+        printf("two param expected\n");
+        exit(1);
+    }
+
+    dst_ip = argv[1];
+    printf("dst IP %s\n", dst_ip);
+    str_buf = argv[2];
+    len = strlen(str_buf);
+
+    if (len % 2) {
+        printf("len should be multiple of 2\n");
+        exit (1);
+    }
+
+    msg = calloc(1, len);
+    if (!msg) {
+        exit(1);
+    }
+    j = 0;
+    for (i = 0; i < len; i+=2) {
+
+        int d1 = charToHex(str_buf[i]);
+        if (d1 < 0) {
+                printf("buf parse error\n");
+                exit (1);
+        }
+        int d2 = charToHex(str_buf[i+1]);
+        if (d2 < 0) {
+                printf("buf parse error\n");
+                exit (1);
+        }
+        msg[j++] = (d1 << 4) | d2;
+    }
+    len = len / 2;
+
+#if 0
+    printf("%d: ", len);
+    for (i = 0; i < len; i++) {
+        printf("%x", (int)msg[i]);
+    }
+    printf("\n");
+#endif
+
+    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+        perror("socket");
+        exit(1);
+    }
+
+    memset(&addr, 0, sizeof(addr));
+    addr.sin_family = AF_INET;
+    addr.sin_addr.s_addr = inet_addr(dst_ip);
+    addr.sin_port = htons(DST_PORT);
+
+    memset(&srcaddr, 0, sizeof(srcaddr));
+    srcaddr.sin_family = AF_INET;
+    srcaddr.sin_addr.s_addr = htonl(INADDR_ANY);
+    srcaddr.sin_port = htons(SRC_PORT);
+
+    if (bind(fd, (struct sockaddr *) &srcaddr, sizeof(srcaddr)) < 0) {
+        perror("bind");
+        exit(1);
+    }
+
+    if (sendto(fd, msg, len, 0, (struct sockaddr *) &addr,
+                sizeof(addr)) < 0) {
+        perror("sendto");
+    }
+    printf("done\n");
+    close(fd);
+    return 0;
+}
\ No newline at end of file
diff --git a/tests/tunnel-push-pop-ipv6.at b/tests/tunnel-push-pop-ipv6.at
index 8c5af459e..7da9ebb15 100644
--- a/tests/tunnel-push-pop-ipv6.at
+++ b/tests/tunnel-push-pop-ipv6.at
@@ -451,7 +451,7 @@ OVS_WAIT_UNTIL([test `wc -l < ofctl_monitor.log` -ge 2])
 OVS_APP_EXIT_AND_WAIT(ovs-ofctl)
 
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
-NXT_PACKET_IN2 (xid=0x0): cookie=0x0 total_len=98 tun_id=0x7b,tun_ipv6_src=2001:cafe::92,tun_ipv6_dst=2001:cafe::88,tun_metadata0=0xa,in_port=5 (via action) data_len=98 (unbuffered)
+NXT_PACKET_IN2 (xid=0x0): cookie=0x0 total_len=98 tun_id=0x7b,tun_ipv6_src=2001:cafe::92,tun_ipv6_dst=2001:cafe::88,tun_flags=key,tun_metadata0=0xa,in_port=5 (via action) data_len=98 (unbuffered)
 icmp,vlan_tci=0x0000,dl_src=be:b6:f4:e1:49:4a,dl_dst=fe:71:d8:83:72:4f,nw_src=30.0.0.1,nw_dst=30.0.0.2,nw_tos=0,nw_ecn=0,nw_ttl=64,nw_frag=no,icmp_type=0,icmp_code=0 icmp_csum:4227
 ])
 
diff --git a/tests/tunnel-push-pop.at b/tests/tunnel-push-pop.at
index 50f90815a..7efcf0bfb 100644
--- a/tests/tunnel-push-pop.at
+++ b/tests/tunnel-push-pop.at
@@ -509,7 +509,7 @@ AT_CHECK([ovs-ofctl add-flow int-br "actions=9"])
 AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(2),eth(src=f8:bc:12:44:34:b6,dst=aa:55:aa:55:00:00),eth_type(0x0800),ipv4(src=1.1.3.88,dst=1.1.3.112,proto=47,tos=0,ttl=64,frag=no)'],
 [0], [stdout])
 AT_CHECK([tail -1 stdout], [0],
-  [Datapath actions: pop_eth,clone(tnl_push(tnl_port(2152),header(size=50,type=110,eth(dst=f8:bc:12:44:34:b6,src=aa:55:aa:55:00:00,dl_type=0x0800),ipv4(src=1.1.2.88,dst=1.1.2.92,proto=17,tos=0,ttl=64,frag=0x4000),udp(src=0,dst=2152,csum=0x0),gtpu(flags=0x30,msgtype=255,teid=0x7b)),out_port(100)),1)
+  [Datapath actions: pop_eth,clone(tnl_push(tnl_port(2152),header(size=50,type=110,eth(dst=f8:bc:12:44:34:b6,src=aa:55:aa:55:00:00,dl_type=0x0800),ipv4(src=1.1.2.88,dst=1.1.2.92,proto=17,tos=0,ttl=64,frag=0x4000),udp(src=2152,dst=2152,csum=0x0),gtpu(flags=0x30,msgtype=255,teid=0x7b)),out_port(100)),1)
 ])
 AT_CHECK([ovs-ofctl del-flows int-br])
 
@@ -600,7 +600,7 @@ OVS_WAIT_UNTIL([test `wc -l < ofctl_monitor.log` -ge 2])
 OVS_APP_EXIT_AND_WAIT(ovs-ofctl)
 
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
-NXT_PACKET_IN2 (xid=0x0): cookie=0x0 total_len=98 tun_id=0x7b,tun_src=1.1.2.92,tun_dst=1.1.2.88,tun_metadata0=0xa,in_port=5 (via action) data_len=98 (unbuffered)
+NXT_PACKET_IN2 (xid=0x0): cookie=0x0 total_len=98 tun_id=0x7b,tun_src=1.1.2.92,tun_dst=1.1.2.88,tun_flags=key,tun_metadata0=0xa,in_port=5 (via action) data_len=98 (unbuffered)
 icmp,vlan_tci=0x0000,dl_src=be:b6:f4:e1:49:4a,dl_dst=fe:71:d8:83:72:4f,nw_src=30.0.0.1,nw_dst=30.0.0.2,nw_tos=0,nw_ecn=0,nw_ttl=64,nw_frag=no,icmp_type=0,icmp_code=0 icmp_csum:4227
 ])
 
diff --git a/tests/tunnel.at b/tests/tunnel.at
index fd482aa87..2dbdc4d7f 100644
--- a/tests/tunnel.at
+++ b/tests/tunnel.at
@@ -1205,3 +1205,128 @@ Datapath actions: push_eth(src=00:00:00:00:00:00,dst=00:00:00:00:00:00),1
 
 OVS_VSWITCHD_STOP
 AT_CLEANUP
+
+AT_SETUP([tunnel - validate tun-flags OAM])
+OVS_VSWITCHD_START([add-port br0 p1 -- set Interface p1 type=geneve \
+                    options:remote_ip=1.1.1.1 options:csum=true ofport_request=1 \
+                    -- add-port br0 p2 -- set Interface p2 type=dummy \
+                    ofport_request=2 ofport_request=2 \
+                    -- add-port br0 p3 -- set Interface p3 type=gre \
+                    options:remote_ip=2.2.2.2 options:csum=false options:key=123 ofport_request=3])
+OVS_VSWITCHD_DISABLE_TUNNEL_PUSH_POP
+
+AT_DATA([flows.txt], [dnl
+actions=load:0x1->NXM_NX_TUN_FLAGS[[]],output:1
+])
+AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
+AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(2),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=4,ttl=128,frag=no),tcp(src=8,dst=9)'], [0], [stdout])
+AT_CHECK([tail -1 stdout], [0],
+  [Datapath actions: set(tunnel(dst=1.1.1.1,ttl=64,tp_dst=6081,flags(oam|df|csum))),6081
+])
+OVS_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([tunnel - validate tun-flags key])
+OVS_VSWITCHD_START([add-port br0 p1 -- set Interface p1 type=geneve \
+                    options:remote_ip=1.1.1.1 options:key=flow options:csum=true ofport_request=1 \
+                    -- add-port br0 p2 -- set Interface p2 type=dummy \
+                    ofport_request=2 ofport_request=2 \
+                    -- add-port br0 p3 -- set Interface p3 type=gre \
+                    options:remote_ip=2.2.2.2 options:csum=false options:key=123 ofport_request=3])
+OVS_VSWITCHD_DISABLE_TUNNEL_PUSH_POP
+
+AT_DATA([flows.txt], [dnl
+actions=load:0x8->NXM_NX_TUN_FLAGS[[]],output:1
+table=2,actions=move:NXM_NX_TUN_FLAGS[[]]->NXM_NX_REG4[[0..3]],output:1
+])
+AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
+
+AT_CHECK([ovs-ofctl dump-flows br0], [0], [stdout])
+AT_CHECK([strip_xids < stdout | sed -n 's/duration=[[0-9]]*\.[[0-9]]*s/duration=0.0s/p' | sort], [0], [dnl
+ cookie=0x0, duration=0.0s, table=0, n_packets=0, n_bytes=0, idle_age=0, actions=load:0x8->NXM_NX_TUN_FLAGS[[]],output:1
+ cookie=0x0, duration=0.0s, table=2, n_packets=0, n_bytes=0, idle_age=0, actions=move:NXM_NX_TUN_FLAGS[[]]->NXM_NX_REG4[[0..3]],output:1
+])
+
+AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(2),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=4,ttl=128,frag=no),tcp(src=8,dst=9)'], [0], [stdout])
+AT_CHECK([tail -1 stdout], [0],
+  [Datapath actions: set(tunnel(tun_id=0x0,dst=1.1.1.1,ttl=64,tp_dst=6081,flags(df|csum|key))),6081
+])
+OVS_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([tunnel - GTP-C using tun optios])
+OVS_VSWITCHD_START([add-port br0 p1 -- set Interface p1 type=gtpu \
+                    options:remote_ip=1.1.1.1 options:key=flow ofport_request=1 \
+                    -- add-port br0 p2 -- set Interface p2 type=dummy \
+                    ofport_request=2 ofport_request=2 \
+                    -- add-port br0 p3 -- set Interface p3 type=gtpu \
+                    options:remote_ip=2.2.2.2 options:key=123 ofport_request=3])
+OVS_VSWITCHD_DISABLE_TUNNEL_PUSH_POP
+
+AT_DATA([flows.txt], [dnl
+actions=load:0x8->NXM_NX_TUN_FLAGS[[]],output:1
+table=2,actions=move:NXM_NX_TUN_FLAGS[[]]->NXM_NX_REG4[[0..3]],output:1
+])
+AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
+
+AT_CHECK([ovs-ofctl dump-flows br0], [0], [stdout])
+AT_CHECK([strip_xids < stdout | sed -n 's/duration=[[0-9]]*\.[[0-9]]*s/duration=0.0s/p' | sort], [0], [dnl
+ cookie=0x0, duration=0.0s, table=0, n_packets=0, n_bytes=0, idle_age=0, actions=load:0x8->NXM_NX_TUN_FLAGS[[]],output:1
+ cookie=0x0, duration=0.0s, table=2, n_packets=0, n_bytes=0, idle_age=0, actions=move:NXM_NX_TUN_FLAGS[[]]->NXM_NX_REG4[[0..3]],output:1
+])
+
+AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(2),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=4,ttl=128,frag=no),tcp(src=8,dst=9)'], [0], [stdout])
+AT_CHECK([tail -1 stdout], [0],
+  [Datapath actions: set(tunnel(tun_id=0x0,dst=1.1.1.1,ttl=64,tp_dst=2152,flags(df|key))),pop_eth,2152
+])
+OVS_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([tunnel - GTP-C using tun optios])
+OVS_VSWITCHD_START([add-port br0 p1 -- set Interface p1 type=gtpu \
+                    options:remote_ip=1.1.1.1 options:key=flow ofport_request=1 \
+                    -- add-port br0 p2 -- set Interface p2 type=dummy \
+                    ofport_request=2 ofport_request=2 \
+                    -- add-port br0 p3 -- set Interface p3 type=gtpu \
+                    options:remote_ip=2.2.2.2 options:key=123 ofport_request=3])
+OVS_VSWITCHD_DISABLE_TUNNEL_PUSH_POP
+
+AT_DATA([flows.txt], [dnl
+actions=load:0x8->NXM_NX_TUN_FLAGS[[]],output:1
+table=2,actions=move:NXM_NX_TUN_FLAGS[[]]->NXM_NX_REG4[[0..3]],output:1
+])
+AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
+
+AT_CHECK([ovs-ofctl dump-flows br0], [0], [stdout])
+AT_CHECK([strip_xids < stdout | sed -n 's/duration=[[0-9]]*\.[[0-9]]*s/duration=0.0s/p' | sort], [0], [dnl
+ cookie=0x0, duration=0.0s, table=0, n_packets=0, n_bytes=0, idle_age=0, actions=load:0x8->NXM_NX_TUN_FLAGS[[]],output:1
+ cookie=0x0, duration=0.0s, table=2, n_packets=0, n_bytes=0, idle_age=0, actions=move:NXM_NX_TUN_FLAGS[[]]->NXM_NX_REG4[[0..3]],output:1
+])
+
+AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(2),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=4,ttl=128,frag=no),tcp(src=8,dst=9)'], [0], [stdout])
+AT_CHECK([tail -1 stdout], [0],
+  [Datapath actions: set(tunnel(tun_id=0x0,dst=1.1.1.1,ttl=64,tp_dst=2152,flags(df|key))),pop_eth,2152
+])
+OVS_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([tunnel - validate QFI Value Set])
+OVS_VSWITCHD_START([add-port br0 p1 -- set Interface p1 type=gtpu \
+                    options:remote_ip=1.1.1.1 options:csum=true ofport_request=1 \
+                    -- add-port br0 p2 -- set Interface p2 type=dummy \
+                    ofport_request=2 ofport_request=2 \
+                    -- add-port br0 p3 -- set Interface p3 type=gtpu \
+                    options:remote_ip=2.2.2.2 options:csum=false options:key=123 ofport_request=3])
+OVS_VSWITCHD_DISABLE_TUNNEL_PUSH_POP
+
+AT_DATA([flows.txt], [dnl
+actions=load:0x6->NXM_NX_QFI[],output:1
+])
+AT_CHECK([ovs-ofctl -Oopenflow14 add-flows br0 flows.txt])
+
+AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(2),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=4,ttl=128,frag=no),tcp(src=8,dst=9)'], [0], [stdout])
+AT_CHECK([tail -1 stdout], [0],
+  [Datapath actions: set(tunnel(dst=1.1.1.1,ttl=64,tp_dst=2152,gtpu(ver=0,flags=0,msgtype=0,qfi=0x6),flags(df|csum))),pop_eth,2152
+])
+OVS_VSWITCHD_STOP
+AT_CLEANUP
\ No newline at end of file
